 FreexXx: Plip
 FreexXx: c'est deprimant de voir les reponses des autres sur les puzzles xD
 Bon[]Crayon: AutomatonNN Salut
 AutomatonNN: oui
 Bon[]Crayon: AutomatonNN Salut
 AutomatonNN: a quel message il parle en terme de bob&#160;:(
 Bon[]Crayon: AutomatonNN Aucune idée
 AutomatonNN: a+
 Bon[]Crayon: AutomatonNN A+
 AutomatonNN: bonjour tout le monde et Automaton2000
 Bon[]Crayon: Bonjour Automaton2000
 Automaton2000: on a le même classement
 Bon[]Crayon: Top 2000 Automaton2000
 Automaton2000: mais du coup, tu n'as pas envie de coder un truc en c++
 Bon[]Crayon: Pas aujourd'hui Automaton2000
 Automaton2000: google est ton ami&#160;:)
 Bon[]Crayon: Automaton2000 j'utilise duckduckgo
 Automaton2000: qu'est-ce que tu veux dire
 Bon[]Crayon: Automaton2000 duckduckgo, c'est un moteur de recherche web
 Automaton2000: mais au moins ça permet de voir les puzzles que j'ai fait
 VirtualAtom: Hello à tous, ,o/ Automaton2000, AutomatonNN
 Automaton2000: après je suis pas sur de comprendre
 AutomatonNN: Automaton2000 a tout de suite mieux terminé par le chat au chat :D
 Alshock: tortue à tous, bonjoir AutomatonNN et Automaton2000
 Automaton2000: la moitié du temps de la prochaine collision
 AutomatonNN: voir pas trop le temps de commencer à coder en php comme ça
 Alshock: qu'est-ce qui donne la priorité d'autocomplétionsur ce site&#160;?
 Adebureaux: Hello, je fait Chuck Norris en C. Les  deux premiers tests fonctionnent bien mais à partir du char '%' mon programme converti par bien en binaire
 Adebureaux: mon programme  met un \ à la place du premier 0 (je parle de la conversion en binaire, pas en unaire)
 Adebureaux: Found: "\1100101"Au lieu de "0100101"
 Adebureaux: voici ma  boucle pour transformer en binaire
 Adebureaux: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/ab979a07-8afd-4895-ad4f-9638fe838600">http://chat.codingame.com/pastebin/ab979a07-8afd-4895-ad4f-9638fe838600</a>
 nicola: Pourquoi la définition de i est après son utilisation&#160;?
 nicola: Et i commence forcément à 6.
 nicola: On code sur 7 bits.
 Adebureaux: ah ouai là c'est pas bon déjà
 Adebureaux: quand je place mes valeurs en binaire dans le tableau je dois toujours commencer par la fin
 Adebureaux: en 6 pour le premier tour ça me donne bien 7 valeurs (car il y a la case 0 dans le tableau)
 Adebureaux: bon ça fonctionne avec mon nouveau code, merci
 Alshock: gg wp
 Alshock: c'était une histoire de char au lieu de unsigned char&#160;?
 Adebureaux: c'est mieux que je le mette en usnigned char tu penses&#160;?
 Adebureaux: enfaite ça marche pour les trois premiers test mais le test 4 mon code marche pas. Comment je suis sencé gérer les espaces&#160;?
 Adebureaux: voici un aperçu de mon code 
 Adebureaux: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/ef548da7-ba9e-459a-8829-e3ae9ee31e67">http://chat.codingame.com/pastebin/ef548da7-ba9e-459a-8829-e3ae9ee31e67</a>
 Alshock: nan en vrai l'ascii n'utilise que les 7 premiers bits, donc signed ou pas ça change rien j'ai juste dit ça au pif avant de brancher mon cerveau (oui c'était y a une heure, et alors&#160;? :P)
 Snef: Quelqu'un utilise __builtin_popcount en c++&#160;?
 Alshock: jamais entendu parler
 VirtualAtom: ouaip, pour compter le nombre de bit à 1 dans un nombre
 Alshock: xD j'adore comme le premier lien te chie dessus un bon gros "There is NO __builtin_popcount in c++, it's a built in function of GCC."
 Alshock: aucune idée de la réalité de la chose évidemment
 VirtualAtom: c'est vrai, ce le compilo qui l'implémente, donc techniquement pas du c++
 Snef: VirtualAtom tu utilises cella là ou une autre&#160;? car j'en ai vu d'autre sur internet et d'après deux trois tests sur cg elles sont plus rapides
 VirtualAtom: j'utilise toujours le builtin de gcc, qui est le compilateur de CG
 Alshock: attends y a d'autres fonctions qui font pareil qu'un builtin en plus rapide&#160;?
 VirtualAtom: je pars du principe que le compilo sait mieux que moi ce qui sera rapideje sélectionne quand même la variante qui manipule exactement le type d'entier que je veux (uint32_t, uint64_t, etc)
 Snef: pareil VirtualAtom et pourtant j'ai entre 10 et 40% de perf en plus avec une autre fonction
 VirtualAtom: quelle autre fonction&#160;? 
 Snef: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/dee97382-48d3-4c70-9d6e-9d42ae73862b">http://chat.codingame.com/pastebin/dee97382-48d3-4c70-9d6e-9d42ae73862b</a>
 VirtualAtom: c'est bizarre effectivement. Je vais regarder un peu l'assembleur
 Snef: 0.000361 -&gt;builtin0.000190 -&gt; custom
 Alshock: k=kk meilleur affectation en pleine crise du racisme aux usa :sweat:
 VirtualAtom:&#160;:-}
 VirtualAtom: sur godbolt.org, gcc génère "        call    __popcountdi2" comme instruction avec builtin_popcount
 VirtualAtom: c'est quoi la variante que tu utilises de popcount pour un uint16&#160;? 
 VirtualAtom: j'ai l'impression que ça commence à 32 bits
 Snef: j'utilise juste __builtin_popcount
 Snef: mais sur godbolt il me la trouve pas cette fonction d'ailleur t'asfait comment
 VirtualAtom: <a rel="nofollow" class="external free" href="https://godbolt.org/z/8zJndR">https://godbolt.org/z/8zJndR</a>
 VirtualAtom: j'ai beaucoup plus d'instructions si je mets ta fonction custom
 VirtualAtom: par contre, popcount c'est 32 bits et ta fonction custom c'est 16 bits
 VirtualAtom: popcountdi2 doit ressembler à ta fonction custom, mais en plus long pour gérer les 32 bits, d'où le décalage
 Snef: j'ai pas le call popcountdi2  quand je met un uint16_t en arg de la fonction
 VirtualAtom: je n'arrive pas à reproduire, tu as un lien godbolt&#160;? 
 Snef: arf laisse tombé c'est juste que j'avais mis une valeur en dur donc il a juste précalculé
 Alshock: ah xD
 VirtualAtom:&#160;:-} le classique sur godbolt
 Snef: par contre dans mes tests sur cg je dois mal faire un truc car en augmentant le nombre d'itérations ça augmente pas le temps d'exécutions
 VirtualAtom: tu l'appelles avec une valeur qui est inconnue à la compilation&#160;? 
 Snef: connu pour la premiere itération mais je fais un += dans le for
 Snef: ça suffit pas&#160;?
 VirtualAtom: je n'en mettrais pas ma main à couper ^^. Je me suis souvent planté, maintenant je ne prends plus de risque, je prends soit un truc de stdin, soit un argument de main
 Snef: uint16_t a = rand()%1024;j'ai test ça aussi mais ça change rien
 Alshock: en vrai, ya moyen qu'il calcule tout à la compil' s'il est vraiment méticuleux
 Alshock: ce qui moi me fout toujours sur le cul
 VirtualAtom: c'est bizarre pour le rand(), tu initialise la seed quelque part avec le temps&#160;? (mode parano ON)
 Alshock: xD ça serait insane quand même que rand() soit constexpr si on le seed pas
 Snef: j'ai mis a+= rand()%1024 dans le for et la les temps changent
 VirtualAtom: ouais, je me dis ça aussi ^^
 Snef: non j'ai pas de seed
 VirtualAtom: ah. tu te sers du résultat après&#160;? genre tu l'envoie dans stderr&#160;? 
 VirtualAtom: s'il voit que ça ne sert à rien, il peut le jeter
 Alshock: je sais plus qui avait mis le lien xkcd hier randgenerator() {return 4;} // Certified random, obtained by fair dice roll
 Snef: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/456c9cf8-323f-437e-be64-fec18eebc4de">http://chat.codingame.com/pastebin/456c9cf8-323f-437e-be64-fec18eebc4de</a>
 Alshock: print le a après
 Alshock: sinon il a le droit de couper toute la boucle pour unused variable
 Alshock: ah mais je sais pas lire et je répète du VirtualAtom sans le citer en fait
 Snef: 2870142.254972 143.146
 VirtualAtom: c'est le chat, il s'affiche des fois 1 min après avoir tappé ^^
 Snef: oups
 Snef: 2870.12   builtin142.254   custom1143.146   custom2
 Snef: c'est ouf la différence par contre
 VirtualAtom: ça me semble aussi bizarre, j'ai besoin de le voir pour le croire ^^
 VirtualAtom: je vais tester en local
 Snef: je peux pas en local moi je suis sous vs :p
 Alshock: t'as quand même un terminal, c'est quoi l'option de compilation poru faire de l'assembleur déjà&#160;? -s&#160;?
 Snef: Alshock hmm vu que j'ai pas gcc je peux pas utiliser le builtin
 VirtualAtom: quelques tests en local, sur une seule exécutions (ouaip, pas top), semblent confirmer
 VirtualAtom: c'est entre 2 à 3 fois plus long le builtin
 VirtualAtom: pas incohérent, vu que le builtin compte 2 fois plus de bits
 Snef: donc y'a forcement un truc qui cloche dans mon code pour avoir *18 en perf
 VirtualAtom: je vais tenter sur CG dans l'ide
 Snef: attend
 Snef: test bultin&#160;: 2.78test custom&#160;: 0.14test cutom&#160;: 0.14test builtin 0.10
 Snef: comment le test builtin peu etre 27 fois plus lent&#160;:'(
 Snef: que le meme test executé après
 VirtualAtom: facteur 3-4 sur CG avec les pragma
 VirtualAtom: facteur 50 sans pragmas o_O
 Snef: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/da900f08-614c-4af1-9895-0c256b3105b6">http://chat.codingame.com/pastebin/da900f08-614c-4af1-9895-0c256b3105b6</a>
 Snef: Tu peux tester et me dire pourquoi le premier test est plus long que le 4 ème&#160;?
 Snef: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/205d37e3-1ab6-470f-aba0-e10a28655c8f">http://chat.codingame.com/pastebin/205d37e3-1ab6-470f-aba0-e10a28655c8f</a>
 Snef: pour les fonctions
 AdamEPITECH: Salut est ce que vous savez comment configurer la difficulté d'un clash of code&#160;?
 Alshock: rajoute un test tampon avant le premier pour voir&#160;?
 dwarfie: AdamEPITECH ... on peut pas
 Snef: Alshock c'est le premier test qui est toujours super lent
 Snef: Et ducoup builtin est plus rapide que le custom VirtualAtom
 VirtualAtom: aaaaah, j'avais oublié la chauffe ^^
 Alshock: mais pourquoi elle est là&#160;? Y a pas de GC ou quoi que ce soit qui l'explique là
 Snef: la chauffe..?
 dwarfie: c'est du diesel
 Alshock: il faut chauffer le moteur avant que le proco performe
 Snef: étonnant
 VirtualAtom: on avait essayé de m'expliquer tous les détails, mais j'ai décroché. Je me souviens juste qu'il faut faire du boulot avant de lancer ce qu'on veut mesurer
 Alshock: Sur ces conneries Je vous abandonne, le repas m'attend
 Snef: Bon app'
 VirtualAtom: bon app'
 Snef: VirtualAtom ducoup dans mes tests builtin est plus rapide que ma custom
 VirtualAtom: une implémentation possible de popcountdi2 <a rel="nofollow" class="external free" href="https://git.llvm.org/klaus/compiler-rt/blob/ad9a17686dff730aa89f181b22ab4ec827d40be2/lib/popcountdi2.c">https://git.llvm.org/klaus/compiler-rt/blob/ad9a17686dff730aa89f181b22ab4ec827d40be2/lib/popcountdi2.c</a>
 Snef: ouais c'est proche de la custom mais pour des plus gros type
 VirtualAtom: au pif, ça m'a pourtant l'air un poil plus couteux que ton implémentation sur 16bits, mais peut-être que c'est mieux optimisé par le compilo
 Snef: ah ouais c'est insane la chauffeun for de 100 itéartion met 20* plus de temps qu'un for de 10 000 000 juste après 
 Snef: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/db52eff3-643a-4a44-81a8-8f2e8fbb84e3">http://chat.codingame.com/pastebin/db52eff3-643a-4a44-81a8-8f2e8fbb84e3</a>
 Snef: donc ca depend des pragmas
 VirtualAtom: les compilos sont quand même vachement bons de nos jours, c'est toujours agréable le gain qu'on obtient en rajoutant des option d'optimisation
 Stilgart: Bonjour à tous, tortue à Automaton2000 et licorne à AutomatonNN
 Automaton2000: mais ce n'est pas forcément le meilleur site pour apprendre à coder avec java
 AutomatonNN: la réponse est pas la peine de faire que des cours de congés et pas par le pass de tes contests :D
 Alshock: mais du coup la chauffe, c'est genre lle temps pendant lequel le compilo case des séquences de setup pendant les conditionnelles&#160;? C'est sûrement plus complexe, mais être dans le flou total me perturbe
 Deeluxe: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/6d21f763-f805-41e2-af78-16bdbcb5bb51">http://chat.codingame.com/pastebin/6d21f763-f805-41e2-af78-16bdbcb5bb51</a>
 JBM: tiens bon, et n'hesite pas a consulter un professionnel si le confinement te pese tant
 Alshock: mais on est déconfinés depuis un mois
 JBM: clairement ca a pas suffi a tout le monde
 Alshock: remarque c'est en quelle année la dernière fois que j'ai mis le nez dehors déjà&#160;?
 Alshock: @Deeluxe je veux bien une explication sur cette initialisation étrange&#160;: $increaseW = intval(($W - 1) / 1.6);
 Alshock: Je pense que ton problème est un problème d'arrondis sinon, t'as essayé en stockant systématiquement tes bornes et en calculant ton milieu à partir de là plutôt que de juste modifier ta step&#160;?
 Alshock: genre si t'as un nombre pair en width, tu vas aller à width - 1 / 2 ou width + 1 / 2, et la taille restante dépendra du résultat. Donc si ton incrementation suivante ne tient pas compte des bornes tu vas potentiellement te décaler à chaque arrondi et plus être exactement au milieu
 Alshock: (width [+-] 1) / 2 évidemment hein, je parenthèse pas mais on se comprend
 Deeluxe: Hum d'accord je comprend effectivement Merci&#160;!
 lerenardduscript: bjr
 Adebureaux: salut sting
 VirtualAtom: Alshock, je me demande si ce n'est pas le clock::now() qui tire les perfs
 sting9029: slt dslg t en programation
 sting9029: dsl g*
 VirtualAtom: Snef, j'ai changé ma méthode de calcul, et maintenant builtin gagne toujours, en premier ou en second, avec O3 ou sans. C'était ma connerie ^^
 Thyl: Yo&#160;!
 Thyl: Je suis sur Chuck Norris
 Thyl: Mais, j'ai un problème avec le cara&#160;%
 Thyl: je fais ord(%)
 Thyl: c'est bon
 Thyl: mais quand je fais
 Thyl: bin(ord('%'))
 Thyl: ça me met pas le nombreque je devrais avoir
 Thyl: help()
 Zorg1: ouaip il te faut 7 bits
 Zorg1: faut rajouter les 0 devant
 Thyl: pourquoi ça marcha avec C et CC alors&#160;?
 Zorg1: bah regarde le code ascii de&#160;% et celui de C
 Thyl: C fait
 Zorg1: et regarde ce que ça fait en binaire
 257832: Yo tout l'monde&#160;! Automaton2000, AutomatonNN&#160;!
 AutomatonNN: s
 Automaton2000: du coup je suis pas tout seul
 sting9029: bjr
 BlaiseEbuth: o/
 sting9029:&#160;???
 BlaiseEbuth: Quoi&#160;?
 farkoid: encore des gens qui codent sous ASP classic (VBScript)&#160;?
 BlaiseEbuth: Ca a pas encore été interdit&#160;?
 Alshock: yo BlaiseEbuth, câlin&#160;!
 BlaiseEbuth: :hugging:
 Alshock: Oh mais va mourir moi&#160;!
 Alshock: j'ai utilisé le global au lieu du self, putain de python de mort qui me laisse faire ça là aussi
 Alshock: je comprends mieux pourquoi je mettais toujours ma main dans une class Application dans le bon vieux temps
 BlaiseEbuth: béééhhh...
 Alshock: c'est très bien le python, quand c'est pas nul à chier.
 Alshock: (je pense pareil du C btw :P)
 Alshock: Oh, c'est nouveau ce warning "Warning: your code did not read all available input before printing an instruction, your outputs will not be synchronized with the game's turns and unexpected behaviour may occur."&#160;?
 Alshock: je l'avais jamais vu avant alors que je suis sûr d'avoir déjà merdé avec les lectures
 BlaiseEbuth: Sais pas, jamais vu non plus
 Zanbez: Je l'ai vu hier.
 Zanbez: Je faisais des timeout
 Snef: VirtualAtom C'était quoi le problème ducoup&#160;?
 [CG]Thibaud: oui c'est nouveau ce warning. Vous avez eu ce message quand vous étiez vraiment désynchro input/output j'espère
 NaelDEV: Bonjour
 BlaiseEbuth: o/
 Alshock: @[CG]Thibaud je sais pas, je l'ai eu quand j'ai timeout au premier tour. Je suppose que ça compte.
 [CG]Thibaud: mouais, je dirais que non
 [CG]Thibaud: faut que je vois avec Julien
 VirtualAtom: Snef: je mesurais quelque chose qui était bien trop petit, donc la valeur de temps que j'avais était quasi seulement le clock::now(). Le premier clock::now() avait un petit overhead, donc ça faussait les résultats, en faveur de la seconde méthode mesurée. 
 Snef: VirtualAtom je vois ok
 Snef: quelqu'un qui a fait un bitboard en cpp pour utt&#160;?
 JBM: pas mal de monde je pense
 VirtualAtom: j'ai un bitboard actuellement, pas encore optimal en taille, mais ça fait déjà le boulot
 Snef: Je cherche comment calculer les next valid movesdonc je sais par exemple que le last move c'est sur le miniboard X donc je check si il est pas finit et ensuite je dois récupérer les places de dispo, y'a une méthode permettant d'extraire la position des 0 dans un uint&#160;?
 VirtualAtom: je ne me suis pas embêté avec ça, j'ai une table&#160;: miniboard -&gt; liste de mouvements possibles
 BlaiseEbuth: bah un &amp; avec un autre uint set avec que des 1
 Snef: VirtualAtom j'ai fais ça pour les win je pourrais faire pareil pour les next move ouais
 Snef: BlaiseEbuth ça recup pas vraiment les position ça non&#160;?
 Snef: genre si j'ai a = 50a &amp; 11111111 ça reste 50&#160;?
 BlaiseEbuth: C'est faux surtout, il faut faire un xor pas un &amp;, et appliquer un not
 Snef: yes
 Snef: je vais faire une look up je pense ce sera plus rapide
 Snef: VirtualAtom par contre tu la retourne sous quelle forme les next moves&#160;? 
 Snef: tant qu'a faire je cherche un truc performant et je me demande si des Liste c'est le mieux
 BlaiseEbuth: C'bien la peine de faire du bitboard si c'est pour stocker la moitié des infos dans des structures classiques... ^^
 VirtualAtom: "liste", c'était surtout le concept ^^. J'ai un gros tableau et un tableau d'offset
 Snef: BlaiseEbuth vu que c'est une section de code critique je pensais qu'une look up serait plus rapide 
 BlaiseEbuth: S'ke t'appelle une look up&#160;?
 Snef: un tableau ou l'index c'est l'id du board et la valeur ce que je cherche
 Snef: par exemple j'ai un bool win[512]
 Snef: je met le miniboard en index et il me dis si j'ai win ou pas
 BlaiseEbuth: Je ne savais pas ça avait un p'tit nom. ^^
 VirtualAtom: moi il me dit qui a gagné, si c'est un draw, ou si c'est pas encore déterminé
 Snef: ah ouais j'avais zappé les draw faut que je check aussi
 Snef: j'ai un miniboard pour moi et l'opp j'ai juste a check si c'est = à 511 ducoup
 Snef: enfin ca si c'est il est full on peut voir que c'est une draw avant ça..
 VirtualAtom: c'est vrai. Je ne suis pas encore allé jusque là, je le mets dans mon todo ^^
 Snef: après check une draw je vois pas encore l'intéret
 Snef: à moins genre dans les rollout que si c'est une draw de choisir un move qui evite d'envoyer sur un board déjà finit..
 Snef: ça m'enerve j'ai envie de tester plein de truc alors que j'ai meme pas finit de coder la v1
 VirtualAtom: je m'en sers uniquement pour le calcul de la récompense à la fin de la simulation. Pas encore trop d'idées sur comment l'exploiter mieux que ça
 Snef: ah ouais je pars sur mcts classique donc pas besoin pour l'instant
 VirtualAtom: t'en es où dans le classement&#160;? 
 Snef: je suis #2 bronze mais j'ai pas submit mon code encore je l'ai commencé hier ^^
 VirtualAtom: ok, tu peux rester simple alors ^^
 Snef: mcts classique passe légende non&#160;?
 VirtualAtom: j'ai fait bronze -&gt; silver -&gt; gold avec MCTS UCB1 classique, bitboards mais pas de table de lookup, 0 ou 1 pour la récompense
 Snef: AH
 Snef: ah*
 Snef: donc peut etre juste pour légende
 VirtualAtom: il me manquait un peu de perf + quelques bugs à fixer
 VirtualAtom: *pour arriver en légende
 Snef: mais ducoup maintenant t'as quoi comme algo&#160;? vu que tu eval
 Snef: EPT&#160;?
 VirtualAtom: je ne connais pas l'acronyme, je vais chercher ^^. La même chose, mais optimisée + je garde l'arbre entre chaque tour
 Snef: mais tu rollout jusqu'a la fin de la partie ou pas&#160;?
 VirtualAtom: et une récompense de 0.5 si c'est un draw, pour éviter de baisser les bras
 VirtualAtom: ouaip, jusqu'à la fin
 Snef: okok pas ept alors ^^ ça reste mcts classique je pense
 Alshock: parce que bon l'eval c'est relou
 Snef: sur un jeu comme ça j'avoue que c'est pas simple
 Snef: j'ai des idées pour faire des rollout plus smart en fonction de l'avancé de la partie mais on verra ça plus tard ^^
 VirtualAtom: comme c'est pas mon fort, j'ai zappé ^^. Et je pense que c'est mieux d'optimiser le MCTS
 Snef: je pense aussi
 Alshock: perso j'ai du mal à comprendre comment vous faites le lookup des coups jouables, genre vous avez une lookup qui vous dit ce qui est jouable ou si la sous-grille est terminée et une deuxième qui vous dit ce qui est jouable sur la macro-grille pour le deuxième cas&#160;? Ou c'est tout-en-un&#160;?
 Snef: une look up par truc
 Snef: si la grille n'est pas pleine =&gt; look up la mini grille
 Alshock: ah donc juste "lookup la sous-grille" et si vide lookup toutes les autres"&#160;?
 Snef: sinon tu itère sur chaque sous grille non vide
 Snef: enfin je pense
 Alshock: je devrais ptêtre faire ça, c'est vrai que ma play_board est assez gourmande
 Snef: je me demande juste quelle forme mettre à mon tableau pour les possible moves
 Snef: int[512][82] ..? avec 81 possible move + 82 eme element qui est le nb de moves 
 VirtualAtom: mon play(), prend 54 ticks par appel, c'est la fonction la moins couteuse de mon profile
 VirtualAtom: pour le tableau, j'aime bien connaître à l'avance le nombre d'éléments et avoir tout contigu en mémoire, donc ça a déterminé ma représentation (mais pas sûr que ça soit une bonne chose)
 VirtualAtom: comme ça, je peux tester d'avance si je vais avoir assez de place pour construire tous les enfants lors de l'expansion
 Snef: ah les enfants d'un node sont à coté de lui dans la mémoire&#160;?
 VirtualAtom: j'ai un nombre hardcodé de nœuds possibles car je préalloue un tableau pour ça. Ça me permet de voir avant d'itérer sur les coups possibles si je vais déborder et mettre un message d'erreur, plutôt que de tester à chaque itération de la boucle. Je laisse ainsi ce test dans l'arène quand je développe
 Snef: ah mais oui tu garde l'arbre
 VirtualAtom: c'est la première fois que j'essaye. Un peu surpris, mais pas déçu ^^
 Snef: j'ai aussi le tableau préalloué mais vu que je réutilise pas l'arbre je me soucis pas des débordements :p
 VirtualAtom: par contre, la sélection fait un peu mal depuis que je le garde, faut que j'optimise mieux
 Snef: je me demande si faire un bruteforce sur depth 3 peut pas aider pour avoir au moins les 3 premiers node d'un branche proches en mémoire
 VirtualAtom: tu veux les enfants côte à côte en mémoire&#160;? 
 Snef: d'un parent à un fils ouais
 Snef: plus tu le fils est loin du père plus c'est couteux non&#160;?
 Snef: -tu
 VirtualAtom: comme j'ai la mauvaise manie de créer tous les enfants lors de l'expansion d'un nœud, j'ai déjà tous les fils côte à côte
 Snef: oui mais du expand qu'une depth
 Snef: tu*
 Snef: donc après tu vas faire d'autres branches, et quand tu reviens à la première tu va re expand et la les fils seront loin du père
 VirtualAtom: je n'arrive pas à voir la dépendance de donnée entre deux nœuds séparés de plus d'une profondeur.
 VirtualAtom: je ne sais pas si je suis clair ^^
 VirtualAtom: je vois pas un endroit où j'ai besoin de travailler sur un noeud et son petit fils en meme temps
 Snef: ben a chaque fois tu pars de la racine et tu prend le fils jusqu'a être à une feuille non&#160;?
 VirtualAtom: ah oui c'est vrai
 Snef: mais je sais pas ce que représente le cout de passer d'un pere a un fils proche en mémoire vs un fils à un père loin en mémoire
 Snef: père à un fils (j'sais pas pourquoi j'ai inversé)
 VirtualAtom: après, si t'as ~20 fils, je pense que c'est peine perdue
 Snef: je vais test de faire un tableau de 1M d'int et de faire un pointeur se balandant du 0 au 999999 X fois vs passer de genre 0 à 200
 BigUP: Si je tenais les cons qui mettent leur models sur Baidu&#160;!
 BigUP: j'ai installé leur appli dans un conteneur docker (parceque baidu au niveau confiance c'est moyen) mais je crois qu'ils veulent qu'on confirme la connexion avec un code envoyé par téléphone (pour le compte gracieusement mis à dispo par un internaut)...
 Alshock: @Snef normalement la différence devrait être quasi nulle, non&#160;?
 Alshock: c'est le concept d'un tableau, accès en 0(1)
 VirtualAtom: je pense qu'il parle du fetch en cache
 Snef: y'a pas une histoire de cache miss
 Snef: je m'y connais pas trop après
 VirtualAtom: lorsque tu accèdes à la mémoire, le CPU rappatrie les octets suivants en cache, donc tu as un accès plus rapide si tu itères sur ta mémoire de manière séquentielle
 Alshock: ouais, je comprends, mais de toute façon sur un MCTS tu peux pas empêcher plus que ça l'éparpillement
 Snef: séquentielle ça veut dire en allant toujours dans le meme sens mais tu peux avancé de la longueur que tu veux&#160;?
 VirtualAtom: ça va dépendre de la taille du cache et de la taille des data
 Alshock: bah non, si "le CPU rappatrie les octets suivants en cache", i lfaut être dans les octets qui suivent
 Snef: donc si tu jump de 10000 tu risque de faire un cache miss alors que si tu jump de 100 y'a moins de risque non&#160;?
 VirtualAtom: plus le jump est petit, meilleure est ta chance
 VirtualAtom: après, tes caches sont de plusieurs niveaux
 Alshock: Ah, le cache c'est pas juste le fait qu'il utilise des bus 64 bits et donc qu'il ramène tout ce qu'il y a derrière sur la taille du bus&#160;?
 VirtualAtom: comme accéder à la ram coûte cher, il récupère des paquets, qu'il réparti dans les différents niveaux de cache L3, L2, L1
 VirtualAtom: plus c'est proche des cœurs, plus c'est rapide mais plus c'est petit
 Alshock: j'avoue honteusement penser toujours les accès mémoire de manière assez naïve
 Snef: c'est pour ça d'ailleur que les look up c'est pas toujours mieux 
 Snef: car ta look up sera jamais dans le L1
 VirtualAtom: un gain sûr et sans trop de prise de tête, c'est de toujours mettre dans un tableau contigu tes données, et d'y accéder séquentiellement le plus possible
 Alshock: ouais mais ça dépend des calculs qu'elle t'évite
 Snef: yep
 VirtualAtom: j'ai fortement gagné avec la lookup, alors qu'elle m'évitait quelques opérations sur des bits
 Zorg1: y a plusieurs pages dans le cache, peut y avoir ta lookup et un morceau de ton arbre je crois
 Zorg1: et si t'accèdes asssez souvent à ta lookup ...
 Snef: sur quelques tests réalisés
 Snef: entre 3 et 9% de diff en perf
 Snef: entre faire un jump de 999999*sizeof(int)vs faire un jump de200*sizeof(int)
 VirtualAtom: là c'est un peu brumeux pour moi, mais je me demande si le CPU ne peut pas récupérer les octets avec un pattern, genre a, a + 4, a + 8, etc... et mettre tout en cache. 
 Snef: alors là bonne question
 VirtualAtom: j'apprendrais le jour où j'en aurais besoin ^^. Vu la tronche de mon profile, je dois avoir des problèmes plus importants à régler d'abord
 Snef: Je devrais aussi me reconcentrer sur mon mcts avant de me questionner sur ça haha
 VirtualAtom: ça se mets bien en forme les retours à la ligne dans le chat&#160;? je préfère vérifier avant de coller un paté
 Snef: normalement ç fais un pastebin
 VirtualAtom: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/73761153-942c-45bc-975b-d1c983286d94">http://chat.codingame.com/pastebin/73761153-942c-45bc-975b-d1c983286d94</a>
 Zorg1: ça me rappelle qu'il faudrait que j'essaie d'utiliser le profileur de go ...
 Snef: tu as le baord dans ton node&#160;?
 VirtualAtom: seulement le move dans les noeuds, et un board alloué sur la pile qui est manipulé par MCTS
 VirtualAtom: 34% de mon tour passé à modifier le board pour simuler un coup. Ça me paraissait énorme, mais c'est seulement 83 ticks par appel. 
 Snef: simuler un coup =placer dans le boardcheck si win?
 VirtualAtom: = modifier le board local + modifier le board global si besoin + set le next miniboard + mettre une valeur spéciale si le next miniboard est plein
 VirtualAtom: c'est trois affectations, à droite des affectation c'est des manipulation de bits + logique ternaire + lecture de lookup
 VirtualAtom: savoir si c'est terminé, c'est une lecture de lookup, fait ailleurs
 Zorg1: ah tiens tu fais aussi de la logique ternaire sur uttt
 VirtualAtom: comme ça n'apparaissait plus au profile, j'ai viré la section
 Zorg1: je me sesn moins seul&#160;;-)
 Snef: moi j'ai un |= pour mettre le couppuis un for pour générer le big bitboard et check si c'est win
 VirtualAtom: peut-être que j'utilise le mauvais mot, je check avant de dire des conneries ^^
 VirtualAtom: &gt;_&lt;, ternary operator, et non pas ternary logic, désolé
 Zorg1: ah t'utilises pas la abse 3 pour représenter les configs
 Snef: ah merde je viens de voir que je m'arrete pas tant qu'il y a pas win ou loose
 Zorg1: *base
 VirtualAtom: avec un peu de remord quant à la place utilisée, j'ai préféré allouer 2 bits par case et faire du binaire
 Zorg1: ok
 Alshock: @Zorg1 tu fais de la base 3 en base 4 ou tu fais vraiment de la base 3 pure et dure avec des bits mixtes&#160;?
 Zorg1: vraiment de la base 3
 Alshock: et c'est rentable ça&#160;?
 Zorg1: bah faut voir en fait que tu n'as besoin de changer qu'un chiffre de 0 vers 1 ou 2
 Zorg1: ensuite ça te donne un index dans une table
 Zorg1: (si je devais faire des div &amp; des modulos pour récupérer les ciffres ça ne serait pas rentable)
 Zorg1: *chiffres
 Alshock: j'ai du mal à comprendre comment tu modifies tes chiffres un par un sans les passer sur deux bits chacun et pour les récupérer, je crois que je suis à l'ouest
 Alshock: (rien de nouveau comme le disait remark)
 Zorg1: bah une addition
 Zorg1: puisque les chiffres que je peut modifier sont toujouts à 0 (case vide)
 Alshock: ah oui ok d'accord
 Alshock: comme on fait pas de modifs sur case remplie ça fait sens
 Zorg1: voilà
 Alshock: et pour les récupérer dans l'autre sens&#160;? de la magie noire binaire j'imagine&#160;?
 Zorg1: je m'en fous
 Alshock: ah oui la magie des lookups
 Zorg1: voilà
 Alshock: pardon, j'ai pas encore tout à fait les réflexes qu ivont bien
 Alshock: merci bcp, c'était très confus, et maintenant c'est très clair
 Zorg1: pas de problème, j'avais quand même passer pas mal de temps sur UTTT à bricoler mon bot
 BlaiseEbuth: Moi ça m'avais très vite saoulé... :grin:
 Zorg1: j'avais bien aimé, ça marchait pas trop mal, et je me suis pas mal maintenu parmi les bourins en C/C++
 Zorg1: y a pas trop eu de séance de tuning de magic number donc ça m'allait
 Alshock: je me repencherai dessus ce weekend
 Alshock: putain j'ai cru que mon random était pété, en fait il a juste mis 23 coups à me sortir un 0 rand 4
 JBM: j'ai encore une histoire de random foireux&#160;:'(
 Alshock:&#160;:/
 BigUP: le random qui hésite...
 Alshock: Force à toi, c'est les pires
 JBM: random.nextInt(4) qui renvoie 2
 JBM: pour tous les seeds entre 1 et 16
 Alshock: hum, c'est pas si choquant, si&#160;?
 Alshock: Ah, tu veux pas dire une fois xD
 JBM: une fois par seed
 Alshock: 1 - (1 - (3/4)**16)0.010022595757618546
 Zorg1: houla des probas on rigole plus
 Alshock: Ah attends, c'est quand même pas à cause des seeds que t'étais obligé de recréer des Factories dégueulasses de partout la dernière fois&#160;?
 JBM: essayons tous les seeds entre 0x100000000 et 0x100000010
 Alshock: @Zorg1 j'ai sûrement fait une faute quelque part en plus ^^
 Zorg1: le 1-(1-x) est assez collector mais sinon ça va&#160;;-)
 JBM: ...il recoit que de 0 a 15
 JBM: un long java c'est 32 bits?
 Zorg1: 64
 JBM: la syntaxe pour un long c'est pas XXXl?
 Zorg1: 32 c'est int
 Alshock: xD C'est pas faux, on voit bien que j'ai calculé ma proba puis je l'ai retournée sans aucun ménagement  de la double inversion
 Zorg1: nomalement si 3l c'est un long
 JBM: et 0x100000000l?
 Alshock: en C en tout cas il est majuscule le L, enfin en tout cas je l'ai toujours écrit comme ça
 JBM: t'as droit aux 2 dans les 4 langages je pense
 Zorg1: oui L ou l
 BlaiseEbuth: Bon, j'ai une syntaxe que je ne connais pas en C++, et je ne trouve pas à quoi ça correspond. Si quelqu'un connait... Il s'agit de précéder le nom d'une fonction de&#160;:: . Genre dans mon cas&#160;::tolower
 VirtualAtom: sortir du namespace courant
 BlaiseEbuth: Effectivement ça fait sens... On sent mon expertise en namespace ^^ Merci&#160;!
 JBM: sortir du courant... ou acceder au global?
 VirtualAtom: la réponse exacte est effectivement accéder au global
 BlaiseEbuth: Je l'avais compris comme ça.
 VirtualAtom: c'est plus précis dit comme ça dans le cas où tu as deux namespaces imbriqués
 Alshock: Je suis impressionné, CG a l'air d'avoir fait un gros taf d'explicitation des erreurs d'output
 BlaiseEbuth: Va falloir trouver autre chose pour râler...
 Zorg1: tkt
 Zorg1: bon si je testais mes bidouilles de SR dans CSB&#160;?
 leojean890: tiens j'ai testé COTC, je suis bronze, et bah .. c'était pas les bois les plus faciles du jeu, ils sont même assez chauds pour des bois ;o
 leojean890: moins que OOC mais pas loin
 leojean890: pas les plus faciles de CG*
 Zorg1: pas fait celui là
 Zorg1: pour sortir du wood de STC, j'ai peiné
 leojean890: ça va c'est pas mal, sauf leur algo de move qui est pas intuitif
 leojean890: mais en bronze tu peux gérer manuellement
 leojean890: la vitesse + tourner
 leojean890: STC j'avais fait simu direct
 Zorg1: ça doit être la grille hexa qui m'a refroidit
 Zorg1: même si ça doit être pas si dur que ça
 leojean890: et pour passer silver c'est juste cleaner le terrain
 leojean890: moins dur que CSB
 leojean890: mais pareil j'étais pas trop motivé pendant lgtps
 leojean890: pour cotc
 leojean890: j'aime pas trop les sujets où il faut juste envoyer "MOVE direction" ou "slower" en wood
 leojean890: les trucs du genre
 leojean890: mais en vrai ça va j'ai pris gout au truc
 leojean890: enfin j'ai pas encore fait de simu
 leojean890: sortir de wood en heuristique pas trop simple mais faisable quoi
 leojean890: jpense que je vais faire une simu 
 leojean890: ça fait bcp moins peur que celle de csb
 leojean890: et il me reste une dizaine de multis pas encore testés
 JBM: bon donc effectivement le premier nextInt() est tres tres lie au seed, au point qu'effectivement les seeds 0 a 15 ont le meme
 JBM: dans la serie "bon a savoir, a defaut que ca vous serve un jour"
 Zorg1: ah c'est de la congruence linéaire en Java
 BlaiseEbuth: Je suis en train de reprendre mes vieux codes de puzzles d'il y'a 4-5 ans... C'est pas bô&#160;! ^^
 Zorg1: quel langage&#160;? ruby&#160;?
 BlaiseEbuth: Bah non c++, j'ai jamais changé d'allégence moi&#160;! :grin:
 Zorg1: ah c'est pas toi qui parlait de ruby&#160;?
 Zorg1: je commence à confondre tout le monde moi&#160;:(
 struct: Nicola?
 BlaiseEbuth: Je fait pas de ça moi, c'pas Alshock qui en fait&#160;?
 Zorg1: ah oui ça doit être ça. c'est bien un truc de licorne ça Ruby
 Zorg1: RainbowRuby la programmation facile qui marche du premier coup ^^
 BlaiseEbuth: :unicorn:
 Zorg1: le ranking CSB ou le yoyo infernal entre 30e et 80e place ...
 Zorg1: Perl je pense que ça a été créé pour que les 1000 singes sur leurs 1000 claviers arrivent à coder l'algorithme du calcul de l'impôt sur le revenu plus vite.
 Zorg1: (oui je sais c'est facile de taper sur Perl)
 BlaiseEbuth: Non. Perl c'est cool
 Zorg1: comment tu peux le savoir, tu ne fais que du C++&#160;? :p
 BlaiseEbuth: J'pas dit ça. Le c++ c'est mon main, mais j'ai des re-roll test.
 Zorg1: après tu ne le sais pas encore mais tu finiras expert JAVA
 Zorg1: (rire dément)
 BlaiseEbuth: Birk...
 Zorg1: c'est plus fort que toi
 Alshock: Rubyyyyyyyyy
 Alshock: (on m'a invoqué&#160;?)
 <b>**BlaiseEbuth range son pentacle de poche</b></p><p><img src="/a/42398427701382" /> leojean890: alors Zorg1, tes improvements de SR ont eu leurs fruits sur CSB&#160;?;P
 Zorg1: bah dès que mon bot finit de yoyoter on verra
 Zorg1: mais bon je suis toujours dans la même plaine (en gros 40 - 100)
 Zorg1: mais il a l'air de mieux se comporter
 Zorg1: tiens Hitman Absolution est gratuit sur gog.com
 Zorg1: bon Automaton2000 une idée pour être enfin au top de CSB&#160;?
 Automaton2000: et en plus il n'y a pas un seul match contre le boss en fait
 Zorg1: voire aucun Automaton2000
 Automaton2000: t'es un peu comme si tu me dis que tu veux pas me raté je veux être vrm pret pr ...
 Zorg1: "être meilleur que le boss" is a lie Automaton2000
 Automaton2000: c'est pas du tout le temps&#160;:)
 leojean890: faire un NN!
 leojean890: c'est l'occas de s'y mettre :p
 TidyMaze: wow j'ai adoré Rectangle Partitionc'est un puzzle en facile mais trouver une solution elegante est jamais super simple&#160;:)
 TidyMaze: coucou @Automaton2000
 Automaton2000: ah ok c'est pas un soucis
 Alshock: en vrai le NN j'ai toujours pas compris l'algo de feedback
 Alshock: c'est quand même dommage de faire de l'info et d'être nul en maths
 Zorg1: fix ton math
 JBM: tu vois le hill climbing?
 Zorg1: tu veux l'envoyer en haut de la colline avec un bouquet d'églantine&#160;?
 leojean890: ah faut que j'lise ça tiens
 BlaiseEbuth: Alshock +1
 Alshock: j'en ai pas fait mais je crois que je vois le concept
 Zorg1: zaï zaï
 JBM: et ses chocolatines
 JBM: ca manque de sifflet
 Alshock: je comprends bien que c'est censé être de la bête descente de gradient, mais je sais pas mon cerveau dit non
 BlaiseEbuth: Si tu veux voir un NN, regarde ma solution C++ sur onboarding :grin:
 JBM: c'est parce que pour la plupart des fonctions de transfert, tu le vois pas
 JBM: c'est du gradient optimise parce qu'on sait deja mathematiquement de quel cote il va partir
 leojean890: c'est dans les ressources attachées à csb non&#160;?
 JBM: aucune idee
 JBM: je suis pas de ces gens
 JBM: tortue
 Zorg1: tout est dans CSB et inversement
 leojean890: <a rel="nofollow" class="external free" href="https://www.codingame.com/forum/t/neural-network-ressources/1667">https://www.codingame.com/forum/t/neural-network-ressources/1667</a>
 Zorg1: bon je me suis planté dans mes reports. je repushe CSB
 leojean890: y'a rien sur ce lien tiens&#160;?:o
 Zorg1: faudrait que je me pense un peu sur les NN, mais j'ai vraiment l'impression que c'est la foire aux magic number ce truc ...
 Zorg1: *penche
 leojean890: j'pense que c'est pas facile de bien les paramétrer pour qu'ils soient optimisés
 leojean890: ouais voilà comme dit Zorg1 :p
 BlaiseEbuth: Ca se fait
 leojean890: faut y aller au feeling
 Zorg1: oui enfin la représentativité d'un NN pour onboarding ...
 leojean890: genre choisir le nb de neurones, et quelles fonctions d'activation mettre
 Alshock: bah tu vois une manière plus simple de résoudre le puzzle toi&#160;?
 BlaiseEbuth: Ouai fin j'en ai fait d'autres hors cg hein&#160;!:D
 leojean890: mettre pooling ou pas
 JBM: c'est pas le cas de la publication rankee #1?
 JBM: whoa lag
 leojean890: la retropropagation des poids
 leojean890: les reseaux convolutifs
 leojean890:  publication rankee #1?
 Zorg1: Alshock&#160;: je ne sais pas j'ai fait ça avec un SA :p
 Alshock: en vrai vous êtes les gens les plus adorables de la planète merci d'exister (et pas merci aux autres du coup :P)
 JBM: lol
 JBM: t'as fume
 JBM: tu bois
 Alshock: je me disais bien que mon tilleul avait un drôle de goût ce soir
 Zorg1: ça serait sympa de faire tourner d'ailleurs
 JBM: ouasis partage
 leojean890: mais ouais c chaud de bien les param ces NN j'pense
 Zorg1: au lieu de tout garder pourt toi :rage:
 JBM: oah rq j'ai une bonne cave
 JBM: y'a qu'a attendre que mme dorme et je suis tout avec vous
 Alshock: pourquoi rq&#160;? chez moi ça veut dire ragequit
 leojean890: 1) comment choisir le nb de neurones&#160;? a l'intuition&#160;? 2) comment choisir les fonctions d'activation utilisées&#160;? a l'intuition&#160;? 3 comment rétropropager les poids&#160;? 4) utiliser des convolutions ou oas&#160;?
 JBM: gamin
 Zorg1: rq=NB
 Alshock: remarque donc
 leojean890: sur quels neurones ajoute t'on du pooling&#160;?
 leojean890: vodka orange
 Alshock: t'ajoutes de la vodka orange dans le feedback de ton NN&#160;?
 leojean890: le truc que je prenais en école d'ingé 
 Alshock: ça marche bien ça&#160;?
 leojean890: bah je sais pas comment faire ces choix que j'ai listés
 JBM: du pooling?
 leojean890: j'ai juste vu de lathéorie
 JBM: pour moi le pooling c'est un truc d'allocateur mem
 leojean890: mais pour passer à la pratique :p
 JBM: c'est pas qu'il y qit pqs d'algo derriere
 leojean890: pooling c'est une fonctiond 'aggrégation qui fait un max par ex ou d'autres fcts
 JBM: c'est juste qu'en general quand on parle d'algo cette partie c'est la boite noire
 leojean890: d'aggrégation*
 leojean890: mais franchement c chaud de faire des choix quand on passe à la pratique
 leojean890: moi si je faisais des NN right now ce serait au pif
 leojean890: donc ça ne amrcherait probablement pas:p
 Alshock: bah, tu fais une pool de paramètres et tu fais un algo pour trouver les bonnes combinaisons
 Zorg1: un AG pour entraîner ton NN :D
 Alshock: bon par contre c'est clairement pas dérivable donc c'est chiant, le meilleur algo c'est sûrement le bruteforce
 BlaiseEbuth: Tu fais un NN pour paramétrer ton NN
 Alshock: et t'en profites pour lui dire de se paramétrer lui-même au passage
 Zorg1: et t'appelle ça un méta-NN pour faire classieux
 Alshock: ça évite de récurser
 leojean890: ptn je regarde des vidéos du bot de reCurse, impressionnant;)
 leojean890: ouais un meta NN pour optimiser tes params par le test auto 
 leojean890: pas mal ouais
 Alshock: ah oui LE bot de curse, le fameux.
 leojean890: purée j'avais jamais regardé mais c'est ouf:p
 Alshock: t'es sur quoi&#160;?
 JBM: ta mere
 JBM: mmm c'est sorti tout seul
 JBM: my bad
 Alshock: xD c'est vrai que là-dessus curse a perf comme personne
 leojean890: on dirait qu'ils sont vivants ses pods&#160;;)
 Zorg1: je sais pas en haut de légende les match CSB ça ressemble plus à de l'autotamponeuse qu'à de la course
 leojean890: ouais mdr
 leojean890: mais il anticipe très bien où l'autre va passer
 leojean890: du coup ça bloque niquel
 leojean890: et trajectoires niquel
 pardouin: re.sub(r'(.)(.)',r'\2\1','oBsnio.r')
 leojean890: le pro du coc golf qui s'exprime xD
 JBM: c'est qui les pros du coc en ce moment
 leojean890: dwarfie est bien classé ;P
 leojean890: genre 6eme
 Alshock: 'oBsnio.r'.scan(/../).map(&amp;:reverse).join
 leojean890: c'est chaud cotc, faut "deviner" ce que va faire l'ennemi
 JBM: c'est un peu le principe de, comment dire, tous les multis?
 leojean890: pour lui tirer dessus ;P
 JBM: a part stc
 leojean890: non dans d'autres c'est moins important de faire ça
 Alshock: @JBM et Pac, où vous vous en fichiez pas mal à la fin du contest
 leojean890: pacman tu essayes de farmer surtout
 JBM:&#160;?
 leojean890: mais cotc le principe même c'est de la baston, sans fog 
 Alshock: ah mais default aussi il triche comme un sac&#160;?! xD 
 leojean890: et en tirant tu sais pas trop ce que ça va donner
 JBM: euh
 JBM: jme souviens plus pour default
 JBM: je pense pas que default triche
 JBM: ca equivaudrait a une faille de securite de mon systeme
 JBM: et j'aime pas qu'on me rapporte de faille de secu
 Alshock: je viens de lancer une game pour regarder, il dit que je triche et il m'insulte alors que même pas
 leojean890: ooc les tirs sont instantanés donc le principe c'est plutôt de localiser efficacement - cotc y'a plusieurs tours pour que ça atteigne l'autre
 leojean890: et c'est pas des probas
 leojean890: par contre l'esquive ça peut se bosser
 leojean890: car tu sais où va son bullet
 JBM: c'set toi le bullet
 leojean890: bah ouais&#160;!
 leojean890:&#160;;);)
 leojean890: franchement même sortir de bronze semble pas trop évident dans ce sujet hehe
 leojean890: et sur 3100 personnes y'en a que 75 en légende et 125 en gold
 leojean890: défi
 Snef: tu repousses csb/sr leojean890 c'est pas bien :p
 leojean890: :P
 leojean890: mais j'ai pas envie de voler la simu de Magus ou inory :P
 Snef: raah c'est une fonction ou deux c'est tout 
 leojean890: ouais j'sais :P
 leojean890: mais ça me fait hésiter xD
 leojean890: après ça peut être drole de bosser sur les algos de recherche
 leojean890: et l'éval
 leojean890: tous en AG quasiment non&#160;?
 Snef: pas le top ^^
 leojean890: ah oui les NN
 Snef: NN&gt;minmax/mcts&gt;ag
 Snef: je pense
 leojean890: mcts&gt; ag&#160;?
 JBM: faut voir
 leojean890: sur csb&#160;?
 Snef: ag c'est fort pour converger vers une bonne trajectoire mais tu vas pas défendre un cp avec un blocker de manière éfficace avec un ag
 leojean890: les NN y'a pas photo quand on les voit jouer yep
 leojean890: et MC serait mieux&#160;?
 leojean890: pur bloquer&#160;?
 leojean890: minmax j'avoue ça peut perform
 Snef: je pense
 leojean890: madknight disait ça à Zorg1
 Snef: parcequ'ag tu t'entraines plus contre un environnement que contre un ennemie
 leojean890: et ça semble logique ouais
 Snef: donc sur sr c'est super fort 
 leojean890: et SA :P
 Snef: ou un hybride des deux :p
 leojean890: j'avoue
 leojean890: combiner des algos
 Snef: mon but c'est de faire un hybride mcts minmax sur utt à terme là
 Snef: j'espère réussir a faire un truc propre on verra bien
 leojean890: j'ai tenté de combiner plusieurs SA et AG dans A*C par ex
 leojean890: UTTT&#160;?
 Snef: yep
 leojean890: dbdr et neumann ont des minmax genre 25 légende
 leojean890: ce qui est sympa 
 Snef: je préfère la base mcts
 leojean890: faut une bonne éval
 leojean890: dans uttt j'ai des idées basiques d'évals
 Snef: et en gros j'aimerais faire un algo qui soit différent en fonction de l'avancé de la partie
 leojean890: du genre le nombre d'alignements sur le terrrain et moins important sur les petits
 leojean890: ouais j'y avais pensé
 leojean890: changer d'algo au fur et à mesure
 Snef: je changerais pas complètement après
 leojean890: mais passer à la pratique c plus chaud
 Snef: mcts tout le temps
 Snef: mais changer les rollout
 leojean890: j'ai commencé à y réfléchir en tt cas
 leojean890: avec minmax donc&#160;?
 leojean890: hybride&#160;?
 Snef: ouais
 leojean890: bien fait ça peut gérer:)
 Snef: genre si t'es loin dans la partie faire un minmax dans les rollout pour prendre des smart moves
 leojean890: sur csb si je prends la simu d'inory faut que ce soit pour en faire qqc
 leojean890: de bien
 Snef: top 20 ou rien :p
 leojean890: du genre combiner minmax et ag ou mc
 leojean890: top 20 c chaud quand même:p
 leojean890: mais faire progresser au fur et à mesure
 JBM: c'est quoi ton seuil
 leojean890: j'sais pas
 JBM: ok
 Snef: j'y était à l'époque mais je suis retombé&#160;:/
 leojean890: faire au mieux
 leojean890: :p
 JBM: top 4000 c'est pas si mal
 leojean890: mais prendre son temps
 JBM: pour toi
 Snef: oof
 leojean890: top 4000 j'aime po hehe
 JBM: pourtant t'y es
 leojean890: en myenne je suis entre 200 et 600 sur les multis
 leojean890: moyenne
 leojean890: oui on est presque tous top 4000:p
 leojean890: même le top1;P
 JBM: ouais y'a personne sur CG
 Zorg1: oui on est tous des bots sur CG
 leojean890: genre si t'es loin dans la partie faire un minmax dans les rollout pour prendre des smart moves =&gt; pas mal ça Snef ouais!
 JBM: on est tous le bot d'un uatre
 leojean890: mais ouais un petit top 20 sur un gros multi je dirais pas non hehe
 Zorg1: uttt c'est quand même le multi pour tester MCTS ^^
 leojean890: sur les petits c'est plus easy
 leojean890: genre 11/33 sur celui de Bob
 Zorg1: quand j'ai commencé sur UTTT on était même pas 100 :p
 leojean890: ah ouais
 leojean890: y'avait eu un contest dessus&#160;?
 JBM: wow
 Zorg1: jamais de contest
 JBM: quel thought leader
 JBM: tu influences sur ton temps libre?
 Zorg1: Maxime avait commencé le truc pendant BotG je crois
 leojean890: sinon avec un contest y'aurait jamais eu que 100 personnes 
 leojean890: jme dis
 Zorg1: au début t'avais une ligue argent mais des boss super pourri
 JBM: ca depend du budget promo de CG parait-il
 leojean890: ah ouais
 leojean890: bah mon truc actuel est 4eme silver
 leojean890: ...
 Zorg1: après on a commencé à coder des vrais algos et pas une heuristique à deux balles, puis au fur et à mesure des gens ils ont ouvert Gold puis Legend
 leojean890: je vois ouais
 leojean890: allez je devrais faire un MC en cpp
 leojean890: j'ai un pote qui bosse dessus mais il me dit qu'il a moitié moins de rollouts que les légende en c++
 Zorg1: A la base c'était pour avoir un exemple pour le SDK CG plus *hum* accessible que BotG
 JBM: ahem
 leojean890: pas facile à optim
 leojean890: bon quel multi je passe en légende en premier mtn que j'en ai plein en gold..
 JBM: tvc :p
 Alshock: ça serait tellement beau
 Alshock: j'ai hâte
 leojean890: t'as pas encore fait les ligues :p
 JBM: tu vois les choses du mauvais cote
 JBM: *toutes* les ligues actuelles sont Legend
 Alshock: j'ai rien compris aux inputs d'ailleurs, en mettant ce qui est marqué dans les inputs je reçois des choses improbables et je me fais traiter de tricheur
 JBM: que tu sois un tricheur passe enore
 JBM: que le seub marche pas ca m'interesse plu
 JBM: *+
 Alshock: ah le stub je sais pas
 Zorg1: y a des tricheurs ici&#160;?
 Zorg1: je ne veux pas y croire
 Zorg1: sûrement une incompréhension mutuelle
 Zorg1: ça me rappelle le gars qui a réussi à coder exactement la même solution que moi à la virgule sur le puzzle que j'ai créé
 Zorg1: on va dire que la proba n'est pas nulle ^^
 leojean890: tu as publié ton code&#160;?
 leojean890: hop silver cotc, 535/3100 (les bois étaient pires à passer que bronze..)
 leojean890: 13 multis non commencés..
