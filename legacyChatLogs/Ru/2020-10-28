 Egrace: понял
 mabu: Всем чмоки в этом чате!
 Egrace: :nauseated_face:
 Uljahn: Egrace: можно на простейшей эвристике долететь, угол пропорционален отклонению положения по Х (от центра посадки) и горизонтальной скорости, только коэффициенты подобрать надо
 Uljahn: angle = K*delta_x + V_horizontal, у меня K получился 1/50
 Uljahn: ну и пару-тройку костылей прикрутить, чтобы ограничивать угол при больших отклонениях и скорости, а также в момент посадки
 BorisZ: мне кажется что наоборот, очень удобная задача чтоб разобраться с генетикой, простая симуляция - никакие враги не мешаются
 BorisZ: оценочная тоже не сложная
 BorisZ: зато навык пригодится потом для других задач и мульти
 gsomix: А кто-нибудь пробовал решить ее с помощью best-first search, вместо генетики?
 gsomix: Кажется, reCurse про это немного размышлял в дискорде. Но сам он не решал эту задачу.
 amurushkin: gsomix можно наверное beam search попробовать еще
 magaiti: вы про оптимизацию mars lander? я тупо физику считал, оптимальную траекторию
 magaiti: если когда-нить вернусь к этой задаче, буду использовать это решение в качестве начального для какого-нибудь алгоритма поиска
 wlesavo: у меня там простенький sa
 magaiti: ну че, как вам кнопка live?
 wlesavo: бесит немного что ее даже в ide видно
 Uljahn: убрал с помощью uBlock как и прочие Jobs и дискорд-дисклеймеры
 Egrace: wlesavo что такое sa?
 Uljahn: simulated annealing
 wlesavo: да, но у меня оно упрощено до фактически жадной эволюции
 Uljahn: жадный MC? или у тебя там скрещивания?
 wlesavo: у меня там только мутации
 wlesavo: это не мс всетаки, в мс должно быть каждый раз сгенерированное решение
 BorisZ: посмотрел стрим с клешами, понравилось как чувар решил задачу - дана доска партии крестики-нолики, надо найти победителя
 BorisZ: он взял список строк из инпута, добавил туда же список столбцов, потом список диагоналей
 BorisZ: и потом просто поиском подстроки в цикле находится победитель
 BorisZ: thinking out of the box
 BorisZ: возможно для всех игр такого типа, на квадратных досках с диагоналями так будет быстрее искать ряды
 BorisZ: хранить доску не как грил а как список всех линий, учетверенная доска
 BorisZ: *грид
 BorisZ: или вобще как длинную строку с разделителями, для питона особенно актуально - циклы медленные, а поиск подстроки быстрый, встроенная функция
 amurushkin: а на такую доску X00 и вторая строка 0.. не тригерится?
 BorisZ: можно джойнить через разделитель
 BorisZ: '|'.join(список рядов)
 amurushkin: хотя вот не понятно. пока он их джойнит уже можно найти победителя по идее
 amurushkin: но метод интересный. для клешей на размер кода возможно самое оно будет
 BorisZ: действительно можно (
 BorisZ: ну это если один раз ищем, если много раз, сначала за одних, потом за других, то может и быстрее -)
 BorisZ: такую доску можно даже менять довольно просто, для всяких переборов, просто не в одной точке надо значение поменять а в четырех точках
 BorisZ: зато потом обход одним циклом стопудобо быстрее чем куча вложенных циклов
 amurushkin: имхо строка не самая лучшая идея хранить состояние доски
 BorisZ: это для питона строка, для си будет одномерный массив большой
 BorisZ: мапнуть (x, y) -&gt; i и наоброт - для изменений
 BorisZ: короче интересно будет попробовать
 Egrace: по времени так же будет как вложеннымиколичество элементов, которые нужно проверять-то не изменится
 Egrace: но мороки с циклами и индексами меньше
 Egrace: я думаю, это отличное решение 
 BorisZ: там же предсказание ветвлений есть один цикл быстрее чем несколько вложенных, при одинаковом количестве элементов
 BorisZ: ну может другая причина какая-то, я не спец, но должно быть так
 BorisZ: хотя может современные компиляторы уже сами разворачивают циклы, хрен его знает, если граница константы то наверное это не сложно
 magaiti: в си двумерный массив и так мапается в одномерный
 magaiti: union { a[4][4]; b[16] };
 MAKMED1337: ERROR: ld.so: object 'libstdbuf.so' from LD_PRELOAD cannot be preloaded: ignored.
 MAKMED1337: что это&#160;?
 MAKMED1337: Answer: malloc.c:2389: sysmalloc: Assertion `(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)' failed.
