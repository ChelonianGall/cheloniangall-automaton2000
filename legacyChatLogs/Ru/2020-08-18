 Uljahn: у меня отображает. попробуй ctrl+f5 нажать, у них постоянно что-то в кэшах браузера застряёт и устаревает
 Uljahn: а, понял. оно не всем показывается же, там тестирование идёт на группах пользователей: одним показывают, другим - нет
 Uljahn: может, куки очистились, если раньше показывало
 SouJll: Благодарю
 gtj: нажми на куку получишь результат)
 gtj: блин)
 gtj: глёва не заводится)
 gtj: Ульян у меня идея)
 gtj: кароче прикинь вот консоль так?
 gtj: без нкурсеса захватить консоль иотредерить 3д)
 gtj: надо всегото переложить 2д спейсы на 3д проекцию) и протянуть перспективу вглубь)
 gtj: идея топ буду пробовать)
 gtj: и все это строковым буфером)
 gtj: я думаю моно такое намутить)
 gtj: 1 буфер есть. 2 теоретически я посмотрел такое можно сделать плюс через вин апи отрубить просто изменение окна2 буфер вроде позволяет быструю перерисовку в любом случае то что я видел рисует риал моментально почти и это было не нкурсес
 gtj: и вот на аски можно рендерить консоль и сцену или из 2д проекции перекидывать на проекции вьювера
 gtj: что нам нужно почти ничего берешь любой лабиринт обсчитываешь длины пространства угол выбираешь чем заполнять будешь
 gtj: перспективу
 gtj: 1 к 2
 gtj: и просто тупо в цикле обсчитываешь вершины
 gtj: ну и так как захват окна кнопки васд делаешь
 gtj: и вот тебе 3д игра в консоли
 gtj: и там как раз можно обкатать паттерн вьювер) и стейтмент)
 gtj: я даже знаю хак как это сделать ведь у многих появился вопрос чо за дичь)
 gtj: надо уменьшать шрифт)
 gtj: тогда все в перспективе будет оч даже красиво)
 Uljahn: ничего не понял, показывай прототип
 gtj: <a rel="nofollow" class="external free" href="https://youtu.be/7sTPrktLLBo">https://youtu.be/7sTPrktLLBo</a>
 gtj: смори
 gtj: просто евент хендлов васд будет делать магию из центра и перерисовывать вершины)
 gtj: 100% такое делали
 gtj: глаз человека реагирует на вершины и перспективу больше ничего не надо
 gtj: достаточно по этим правилам хотябы обновлять сцену)
 gtj: из центра!
 gtj: из центра внтреннего куба
 gtj: можно назвать планом вьювера в перспетиву
 gtj: ну а в автокаде ты наверно работал
 gtj: если рубишь в проекции то вполне походу реализуемо
 gtj: я понял фичу эту)
 gtj: как линза работает
 gtj: ну а потом просто вместо елементов аски этот алго вставляешь в жль и так и делается)
 gtj: просто пиксели перебираются пикселей же больше
 gtj: блин ты про бсп не смотрел просто там как раз про проекцию сверху рассказывают как сделать в 3д
 gtj: посути как в геометрии
 vrabosh: можно я тоже тут пофлужу)
 gtj: тоесть из вида сверху можно просто проецировать
 gtj: Врабошь на бумаге задай константы расстояний вершин общих и перспективы и нарисуй лабиринт
 Uljahn: vrabosh: только без оскорблений
 gtj: лабиринт вид сверху
 gtj: и по своей формуле переведи в 3д
 gtj: это линза
 Uljahn: всё равно в этот чат никто ничего писать не будет толкового
 gtj: вернее это преломление лучей света
 gtj: а вьювер имитирует линзу
 gtj: ладно пойду заморочусь
 vrabosh: не надо замарачиваться
 vrabosh: забей)
 Uljahn: пофлуди ещё с нами)
 gtj: так это основы
 gtj: просто пиксели меньше букв
 vrabosh: получилось н асме графы написать в 512байт?)
 gtj: почему 512 байт
 vrabosh: хз, красивое число
 gtj: регистры 32 битные в масме32
 vrabosh: ты если на асме напишешь игру тиктактое, это ваще будет круто
 vrabosh: топ1 займешь
 gtj: ее можно вставками написать сам асемблер закрыт 
 vrabosh: ну на Си вставить асм код
 gtj: нет я щас отдыхаю от графов
 vrabosh: рано отдыхать
 vrabosh: они такие, если доконца недоделать, то убегут
 gtj: надоело хочу по фану написать что хочу
 vrabosh: вот по фату тиктактое
 vrabosh: там графов нет
 gtj: бфс работает и дфс рекурсивный что тебе еще надо)
 gtj: в тик таке есть хитрые методы
 Uljahn: кирка уже зарешал?
 Uljahn: на асме)
 gtj: я это все отложил мозги закипели там пробовать надо теперь по стеку возвращаться
 Uljahn: любишь рекурсию - люби и по стеку возвращаться
 gtj: а так тоже самое щас пишется и на асме
 gtj: там библиотек мама не горюй
 gtj: от винды
 gtj: теперь 1 кнопкой можно окошко создать
 gtj: njtcnm xnj z gjyzk hfpybws ytn rfrjq ,eath
 gtj: тоесть что я понял разницы нет какой буфер и какой наполнитель все формулы теже
 gtj: щас есть задумка если получится попробую потом сюда задачку написать)
 vrabosh: жиэль на асме получится сделать?
 gtj: а я хз
 gtj: просто это самое интересное для
 gtj: оттуда я и пришел в интерес программинга
 gtj: я видишь сам нифига не знаю пробую все что нравится)
 gtj: ну и плюс чутка гуглю
 gtj: посмотри про бсп деревья
 gtj: как просчитывают вершины на проекции от 1 лица
 gtj: проекции можно взять из карты 2д
 gtj: иметь координаты и просто переносить точки на главную проекцию
 gtj: координаты пространства
 gtj: а дальше зависит от настроек констант перспективы и вершин 
 gsomix: gtj, не пробовал найти чат по интересам? В телеграме, например, много разных. В том числе про разработку игр и компьютерную графику.
 gsomix: Здесь это оффтоп, а так нашел бы себе соратников со схожими интересами.
 gtj: бфс и лабиринт еще тот оофтоп
 gtj: 1 этого достаточно плюс порисовать чтобы понять что это как бы намекает прям) кричит)
 gsomix: gtj, Коль, ну хорош.&#160;:) Взрослый мужик, а все ерундой в чатах страдаешь. Ты рисуешь нормально, еще программировать учишься — занялся бы разработкой игр, если нравится, да общался бы в чатах схожей тематики. Зачем здесь флудить? Тем более люди жалуются.
 vrabosh: gtj , покажи рисунки свои?
 Uljahn: "занялся бы разработкой игр" :upside_down:
 vrabosh: так еще и на с++ программит и в асм разобрался и линукс норм знает)
 vrabosh: так что тебе полюбому свой канал создавать и советы школьникам раздавать, они будут очень рады.
 vrabosh: некоторые даже денег могут заплатить
 Uljahn: на транзисторах нейронку придумал, можно уже на кикстартер выходить
 vrabosh: оо это я пропустил) это интересно..
 mykeich: давно был какой-то человек что делал простых роботов на пару транзисторах, которые бесцельно ездили по полу квартиры. ну и сложные тоже делал
 BorisZ: находясь в здравом уме и твердой памяти согласен на тест кика
 Uljahn: ok let's test kick
 Uljahn: yep, it works :thumbsup:
 gtj: народ вы чего это уже давно придумали
 gtj: просто вся вереница изучения эффекта памяти оттуда и пришла из смежной области
 gtj: посмотри на слои нейронов представленных в любой нейронке
 <b>**tutubalin slaps gtj around a bit with a large fishbot</b></p><p><a href="/wiki/File:Default_avatar.png" class="image"><img alt="Default avatar.png" src="/images/5/56/Default_avatar.png" decoding="async" width="50" height="50" /></a> gtj: переверни
 gtj: похоже же на каскад
 gtj: ладно пофиг
 gtj: <a rel="nofollow" class="external free" href="https://siblec.ru/img/46/img/1/Image3267.gif">https://siblec.ru/img/46/img/1/Image3267.gif</a>
 Uljahn: может быть, ты знаешь, как сделать бэкпроп на транзисторах?
 gtj: предположить могу
 gtj: и скорее всего это уже есть
 Uljahn: то есть, не знаешь, но продолжаешь натягивать аналогию на глобус
 gtj: ну для начала это обратное рассеивание да?
 Uljahn: обратное распространение ошибки по формуле с частными производными
 gtj: угу
 Uljahn: тот самый градиент, который ты так любишь
 gtj: ладно я лучше скажу не знаю
 tutubalin: Uljahn по идее можно обучить нейронку заранее, а на транзисторах уже сделать железячную реализацию.понятное дело, что дальше она уже учиться не сможет, но работать в рамках обучения будет
 gtj: <a rel="nofollow" class="external free" href="https://ru.wikipedia.org/wiki/Комбинационное_рассеяние_света">https://ru.wikipedia.org/wiki/Комбинационное_рассеяние_света</a>
 <b>**tutubalin slaps gtj around a bit with a large fishbot</b></p><p><a href="/wiki/File:Default_avatar.png" class="image"><img alt="Default avatar.png" src="/images/5/56/Default_avatar.png" decoding="async" width="50" height="50" /></a> gtj: тут все на интерпретации завязано но такое есть и это связано с обратной связью кто именно ее начинает я хз
 gtj: логично что ее начинает определенное состояние на обратной связи
 gtj: может когда до определнной точки доходит начинается обратное рассеивание но при рассеивании потребляется больше мощности
 gtj: и потом нейроны на ячейках
 gtj: любое представление ячеистой структуры подходит а транзисторы ближайшие и я походу не о тех транзисторах еще думаю
 gtj: а о других
 gtj: кароче я хз
 Uljahn: чтобы перенести веса с цифровой нейронки на транзисторную, надо обучать её с такой же функцией активации, что и нелинейность транзисторной характеристики
 gtj: просто предположил
 gtj: да тоесть бис на открыт закрыт должны схватывать
 gtj: вобщем в истории было такое
 gtj: тут к слову еще графы завязаны
 gtj: кароче я не помню чо читать надо чото с компами толи процы толи память толи бис сбис
 tutubalin: Uljahn сейчас самая модная функция активации ReLU. я не особо в схемотехнике, но вроде можно заменить диодом
 Uljahn: можно, наверное
 Uljahn: там ещё надо будет веса в коэффициенты усиления преобразовать, обеспечить защиту от наводок, и в результате получится тёплая ламповая нейронка&#160;:)
 gtj: программируемая
 gtj: и придем к чему пришли)
 gtj: к машине тиринга
 gtj: или кого там
 tutubalin: gtj убедительная просьба не флудить
 Uljahn: я не вижу особых преимуществ кроме быстродействия, но современные нейронки вроде и так не тормозят со всеми этими TPU и нейропроцессорами
 tutubalin: Uljahn в последнее время часто попадается информация, что некоторые огрехи в реализации нейронок не особо плохо сказываются, а иногда даже наоборот помогают
 tutubalin: например, использование FP16 должно сильно сказаться на точности, но результаты особо не страдают
 Uljahn: tutubalin: я читал, что при обучении в RL подмешивают шум в полезный сигнал, чтобы нейронку можно было из модельных условий перенести в реальные
 tutubalin: какие-то ребята ускоряли обучение с помощью параллельных потоков. иногда у них получалось, что один поток перезаписывал результаты другого - и опять же это в некоторых случаях даже шло на пользу
 gsomix: Интересная вариация — optical neural network. Но это продолжение старой идеи с вычислениями на оптических компонентах: дифференцирование, интегрирование.
 gtj: да и все потомучто интел подмешивает лучшую на сегодняшний день оптимизацию кодом
 gtj: 5 летт назад так было щас вот правда я не вкурсе
 Uljahn: перезапись похожа на drop-out, а FP16 - на квантизацию, когда веса огрубляют, чтобы меньше места занимали, и вычисления ускорить, при этом точность может снижаться незначительно, во фреймворках встречал quantization aware training
 gsomix: А как часто в топе встречаются нейронки? По сравнению, например, с классическими методами глобальной оптимизации?
 tutubalin: зависит от задачи
 Uljahn: inoryy говорил про ландшафт пространства состояний игры, если он более-менее плавный, то нейронки имеют шансы, если рваный как в крестиках - то не очень
 wlesavo: tutubalin вроде бы для офф полиси методов перезапись прямо часто применяется. хотя в вычислительных задачах такого делать нельзя если нужен точный результат, а вот в обучении может реально ускорять процесс заметно
 Uljahn: gsomix: в гоночках топ-4 точно нейронки, есть ещё в Oware парочка, больше так сразу не вспомню
 wlesavo: в oware вроде больше чем парочка
 Uljahn: т.е. их не так уж много - очень сложно всю кухню прикрутить и впихнуть результат в ограничения CG
 wlesavo: ну да, обучить одно дело, а задеплоить на cg совсем другое
 Uljahn: а, Zuko3D ещё во время контеста LoCaM умудрился обучить нейронку
 inoryy: маленькое уточнение: на TPU юзается bf16, а не fp16&#160;:) 
 inoryy: и оно не совсем квантизация и к сожалению не совсем безболезненно
 gybson_samara: где получается целевую функцию придумать, там можно и нейронку сунуть
 tutubalin: TPU может быть. а nVidia fp16 использует
 tutubalin: хотя это 3 года назад было. может быть что-то уже поменялось
 inoryy: там речь про TPU была, ну да ладно. у нвидии теперь tf32
 gtj: чем отличается вывод без буферизации от вывода с буферизацией? кажется просто но я кажись стал плыть)
 tutubalin: я вообще про fp16 узнал, когда один мой знакомый (он не по нейронкам, а по фоторедакторам специализируется, но тоже нужна скорость) жаловался, что 65535 не влезает в fp16
 tutubalin: gtj любая операция ввода-вывода помимо непосредственно ввода-вывода требует определённых сопутствующих операций.если выводить по одному символу, получается большой оверхед.буферизация помогает собрать сразу много много данных и вывести их все одним блоком
 tutubalin: плюс: повышается быстродейтсвие. минус: выводимые данные могут какое-то время (иногда продолжительное) сидеть в буфере и не выводится
 Uljahn: иногда до вывода может дело и не дойти, как на CG было с выводом в дебаг в питоне, когда часть сообщений терялась при возникновении ошибки, помогал параметр flush=True, который принудительно выводил содержимое буфера, насколько я понимаю
 gtj: ага клевая тема не так проста как кажется можно прям забивать иногда на строки и сразу с буфером работать
 gtj: заметил 1 нетривиальное действие только
 gtj: если задать массив чаров двойной указатель и выделить память под строки а потом пройти по столбцам тогда будет оверхед
 gtj: проще сразу напрямую юзать буфер
 gtj: там даже не поймать момент где ты вышел за область
 gtj: он просто улетает
 gtj: хотя по коду читаешь не должен
 tutubalin: С++ не гарантирует, что двухмерный массив будет хранится в одном месте.двухмерный массив - это массив указателей
 gtj: да вкурсе
 gtj: видимо если многофайл тогда буфер ага а если мейн разработка то можно
 gtj: я по туториалу если что решил затестить
 tutubalin: gtj убедительная просьба не флудить
 gtj: кстати в туториале не так говорят как ты каждый массив указателей рядом расположен
 gtj: но не весь двумерный массив
 gtj: ну значит высота вылетает
 gybson_samara: Uljahn теперь Flush=True просто сразу в шаблоне кода начальном =)
 Uljahn: теперь-то да, но раньше часто приходилось в чате подсказывать
 wlesavo: gybson_samara это ж целая компания велась чтобы в stub питона Flush=True добавить 
 tutubalin: сейчас вроде и без этого работает
 daddio: 1342139f14a66940f9a6c0670d385499c44ffcc
 tutubalin: daddio убедительная просьба не флудить в чат
 tutubalin: а вот если использовать MCTS не для мультиплеера, а просто для поиска в дереве (тот же SameGame или скажем комивояжёр), то как в таком случае подбирать константу?
 Uljahn: по синтетическим тестам?
 wlesavo: здравый смысл + метод тыка. + для выбора нод тебе все равно эвристики нужны некоторые со своими константами, которые тоже будут зависеть от основной 
 wlesavo: еще зависит от того как ты скор нормируешь
 Uljahn: интересно, будет ли оптимальная константа зависеть от усреднённого коэффициента ветвления и от бюджета времени? здравый смысл тут уже переходит в интуитивные догадки
 Uljahn: при разной нормировке скора есть теоретически оптимальные значения, от которых можно плясать
 wlesavo: ну + оптимальное значение может и от задачи зависеть я думаю, например если легко сходится к оптимальному решению то ширина не так важна, а если много локальных минимумов, то ширина нужна побольше. но это опять же из задачи не всегда понятно
 Uljahn: поэтому и предлагаю несколько тесткейсов сделать с подходящей сложностью, и для них подбирать, вроде так в научных статьях делают :smiley:
 wlesavo: ну я это называю методом тыка
 Uljahn: угу, научного тыка (тыкать в районе теоретического оптимума)
 tutubalin: вообще как я понимаю смысл этой константы (точнее вообще всего слагаемого):у нас есть некая эмпирическая оценка, полученная рандомом. возможно нам просто не повезло, и реальное значение этого нода лучше. по сути это слагаемое показывает, насколько лучше может быть реальная оценка
 tutubalin: при этом оптимизм умеренный: вероятность пожалеть о том, что мы пошли в этот нод не должна превышать вероятность того, что оптимистичная оценка верна
 tutubalin: при этом предполагается, что оценка ограничена сверху функцией Гаусса. и вот если у нас значения могут быть от -1 до 1, медиана в нуле, то константа корень из двух отлично туда ложится
 tutubalin: а если я например применяю для Code of the Rings, то оценка каждого нода - это длина программы. А она, в зависимости от входных данных, может быть в самых разных пределах. От нуля до бесконечности. И как её нормализовать - не понятно.
 Uljahn: а что в нодах? команды программы?
 Uljahn: или набранный символ строки?
 735487: tutubalin: нормализовать как всегда. разделить на большее. я так в csb делал
 inoryy: эта константа идёт от подсчета оценки на верхнюю грань доверительного интервала, отсюда и название UCT
 tutubalin: amurushkin а если нужно наоборот минимизировать это число?
 tutubalin: Uljahn так как у меня циклы пока не предусмотрены, в нодах - выбор, какую ячейку использовать для создания очередной буквы
 735487: ну какая разница. если нужно минимизировать сделай отрицательную оценку
 Uljahn: а в роллаутах что тогда? добивание остальных символов рандомными метаниями?
 Uljahn: inoryy: там вроде ещё понятием regret оперируют
 inoryy: да, потому что оно всё изначально из bandits theory где весь фокус на regret minization 
 tutubalin: inoryy ну вот я не совсем понимаю, как этот regret minimization пересчитать на более широкий диапазон
 tutubalin: Uljahn идея такая. есть жадный алгоритм: для каждой новой буквы выбираем, из какой существующей буквы её проще всего получить (сколько нужно команда на дойти + поменять)
 inoryy: ну надо копать в их теорию; есть спец методы по которым подсчитывать upper bounds исходя из характеристик среды и етц
 tutubalin: есть DP: для каждой новой буквы рассматриваем все возможные предыдущие состояния и для каждого состояния выбираем каждую возможную ячейку, куда можно записать новую букву. получается ещё большее множество состояний, которое будет потом использоваться следующей буквой.если ограничить память пятью-шестью ячейками, то работает норм. если семь и больше, количество состояний начинает довольно быстро расти
 tutubalin: теперь MCTS. каждый нод - это в какую ячейку решили пойти.вместо рандомного ролаута - жадный алгоритм (см.п.1)
 tutubalin: когда дошли до конца дерева, узнаём суммарное количество команд и отправляем это число родителям. и вот встаёт вопрос, о доверительном интервале
 tutubalin: допустим у одного нода очки 1200, у другого 1400. насколько первый привлекательнее второго? до сколько должна вырасти N (количество ролаутов через их родителя), чтобы MCTS решил попробовать второй нод?
 BorisZ: 1
 BorisZ: tutubalin там же циклы есть еще
 BorisZ: в code of the rings
 BorisZ: минимальное число коменд без учета циклов высоко не встанет, надо под них подстравивать все
 tutubalin: там разные тесты есть. в некоторых циклы всё разруливают, а в других почти никак не помогают
 tutubalin: если алгоритмически решать, то кроме простых циклов типа [-], [+], [&gt;] довольно сложно что-то придумать
 gybson_samara: tutubalin можно же в циклы потом упаковать
 Uljahn: хм, для CotR же валидаторы известны
 Uljahn: смысла особого нет упираться
 tutubalin: я с ними и работаю. просто для некоторых из них легко руками написать (например, 31 Z подряд), а для некоторых проще комп заставить перебирать (например последний валидатор про кольцо)
 gybson_samara: а брутфорс его не берет?
 gybson_samara: автомат-то простой, херакнуть перебор с ГА  =)
 Uljahn: наверное, это уже не брутфорс, а метаэвристическая оптимизация, которая субоптимальное решение ищет
 tutubalin: когда нужно сгенерировать строчку в 360 символов, брутфорс вряд ли поможет
 tutubalin: даже вот строчка в 85 символов. у меня её вчера DP часа 4 перебирал. ноутбук разогрелся, что можно было котлеты жарить
 gybson_samara: так это мэджик фраза такая, а строка автомата может и маленькой быть
 tutubalin: про генетику я тоже думал. идея похожая: берём рандомный код, запускаем. потом жадным алгоритмом доводим его результат до требуемой магической фразы. смотрим, сколько в сумме получилась длина.по этому параметру делаем отбор.
 tutubalin: проблема возникает, если рандом начинает использовать операцию вывода и выводит что-то не то. особенно если делает это в цикле
 tutubalin: мне кажется, рандомные мутации будут это очень долго исправлять
 YurkovAS: у кого-нибудь есть точная симуляция Code vs Zombies? не получается сделать, постоянно на 1px расходится прогнозирование след. позиции зоби. Проверял floor, trunc, round.
 tutubalin: а хранишь координаты в целых?
 735487: может попробовать менять порядок ходов?
 YurkovAS: во float
 735487: у меня есть чужая симуляция за счет которой я ачивку делал. но я не знаю насколько она точная
 YurkovAS: эта?<a rel="nofollow" class="external free" href="https://github.com/cpiemontese/code-vs-zombies/blob/master/solution.c#L462">https://github.com/cpiemontese/code-vs-zombies/blob/master/solution.c#L462</a>
 YurkovAS: так тоже расходится.как сравниваю, применяю через свою симуляцию 1 ход и потом сравниваю, что в игре приходит.часто в 1пх расходится.
 YurkovAS: может это и нормально, что расходится в 1пх.не получается сделать, чтобы все тесты проходило.замучался уже...
 735487: а если на double делать?
 735487: на 1 пиксель это фигня наверное. гораздо важнее насколько разойдется через 10 тиков
 tutubalin: мне кажется, проблема в том, что рефери хранит в интах, а ты во флоатах. поэтому есть небольшое расхождение, которое накапливается
 YurkovAS: в int-ах тоже проверял, было аналогично.щас еще проверю double, int
 tutubalin: зомби, у которых координаты отличаются, вообще любые могут быть или только те, которые за стрелком бегут?
 YurkovAS: у зомби есть координаты nextX, nextY вот с ними проблемы в 1пх.
 735487: просто вычитай 1пх ))
 YurkovAS: да там рандомно +-1 то в х, то в у
 Uljahn: кстати, -ffast-math и -O3 в прагмах влияют на точность же?
 tutubalin: ну некоторые зомби бегут за людьми, которые статичны, а некоторые бегут за главным героем.вот есть подозрение, что погрешность случается только у вторых
 YurkovAS: за статичным когда.
 735487: может быть влияет кого первым двигать. героя или зомби
 gybson_samara: δ[k] = o[k]*(1 - o[k])*(o[k] - tk) - что такое tk?
 Uljahn: Training data: t2 - expected output of O2
 Uljahn: tk - ожидаемый выход k-го слоя, похоже
 Uljahn: или выходной ноды, а не слоя
 gtj: математически похоже на обратную последовательность минус текущее помноженное на общее количество возможностей
 gtj: n-1 1-n мб както связано математически
 gtj: если длинна 12 символов и предположить что есть множества разные то получается 86 в 12 степени переборов
 gtj: я хз за скоко щас такое перебирается когда я учился было дохрена лет переборов конечных последовательностейц
 gtj: 100 000 000 000 000 000 000 000 сочетаний
 gybson_samara: Uljahn аа, ну т.е. ошибка
 ilgiocatore: сумел сегодня получить ачивку в code vs zombies без симуляции и с очень простым кодом: ищу ближайшего человека и бегу к точке между ним и ближайшим к нему зомби ) может кому пригодится, раз уж про это заговорили
 vrabosh: начал учить математику с 4 класса, получается попрограммерски)
 vrabosh: b/n, '==', b//n + (b - b//n*n)/n # b // n - целая часть
 gybson_samara: этот пазл с нейронкой прям такой ... пойди найди что не так =)
 tutubalin: gtj только символов не 86, а 27. и надо перебирать не их, а программу на brainfuck
 Uljahn: ему лишь бы ляпнуть чего
 tutubalin: ilgiocatore но фишка не только в том, чтобы пройти, но и чтобы побольше очков собрать. то есть мало спасти людей, нужно ещё и зомбей долбить красиво
 Uljahn: так он пишет, что хватает на ачивку
 Uljahn: естественно, с такой эвристикой в топ не выйдешь
 tutubalin: но вообще эвристика красивая. у меня гораздо сложнее получилось
 tutubalin: правда там есть один тест, где ближайшего человека всё равно съедят и если бежать его спасать, то и второго съедят тоже
 YurkovAS: так то норм игра
 tutubalin: я вижу, Puzzle of the Week не всем дался )
 tutubalin: чтобы вас как-то вдохновить, вот вам интерпретатор BF в 288 байт на питоне: <a rel="nofollow" class="external free" href="https://codegolf.stackexchange.com/questions/84/interpret-brainf/187127#187127">https://codegolf.stackexchange.com/questions/84/interpret-brainf/187127#187127</a>
 gybson_samara: ниче так разогрел пулику =)
 gybson_samara: публику
 gybson_samara: а до этого про лордов коды говорили, чет падазрительна
 vrabosh: зомби вообще классная тема, но там надо посидеть хорошенько подумать как сделать чтоб много очков набивать.
 gybson_samara: tutubalin stdout.write на питоне?
 gybson_samara: а чо вы молчите, что теперь не надо в принте str писать?
 gybson_samara: можно прям так аргументы, без приведения к строке
 tutubalin: gybson_samara в принципе аналогично print(x,end=<i>)</i>
 tutubalin: количество символов одинаковое получается
 gtj: не понимаю как строковый буфер превратить из линейного в кадровый)
 gtj: о посмотрю реализацию кирка
 gybson_samara: про stdout хитро
 gtj: если интересно бьюсь с первыми 2 минутами из этого видео перевожу это в++
 gtj: <a rel="nofollow" class="external free" href="https://youtu.be/7sTPrktLLBo">https://youtu.be/7sTPrktLLBo</a>
 gtj: вот тут он реализовал почти 1 в 1 буферы очистки и выброса
 gtj: а в ++ не так тривиально
 gtj: я много нового для себя узнал
 gybson_samara: tutubalin твой код валится чет
 gtj: а может быть такой что дфс все пути вернет?
 gtj: чисто вот гипотетически хотя сейчас более детально проверю
 gtj: классно я разобрался)
 gtj: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/2f2fed7d-e6ca-4891-91be-08f7303de5ed">http://chat.codingame.com/pastebin/2f2fed7d-e6ca-4891-91be-08f7303de5ed</a>
 Pyhesty: ооо!!! русский язык!
 Pyhesty: вы настоящие?
 Pyhesty: обьясните, как считается ранкинг? я в wood лиге, место 210, но смотрю все бои, мой бот выигрывает? почему так?
 zuko3d: что за игра?
 zuko3d: для ранкинга обычно используется TrueSkill, т.е. повышение твоего рейтинга зависит в том числе от рейта твоих оппонентов. Но обычно за 100-150 игр твой ранк приходит к настоящему
 Pyhesty: но я не могу понять, как улучшать бота, если после сабмит проходят игры с моим ботом и там нет пройгрышей (видимо в моей лиге дефалтные боты)
 Pyhesty: я могу сыграть ботом с любым ботом из моей лиги?
 Pyhesty: игра пакмен, собирать зеленые плюшки... <a rel="nofollow" class="external free" href="https://www.codingame.com/multiplayer/bot-programming/spring-challenge-2020">https://www.codingame.com/multiplayer/bot-programming/spring-challenge-2020</a>
 zuko3d: эммм... я смотрю твои игры и там куча проигрышей из-за таймаута
 Pyhesty: я только сейчас понял, что есть проблема с тайм аутом, когда я играю за второго плеера....
 Pyhesty: (pacId is always 0 in this league). проверяю pacID написано, что всегда 0... но может быть он ждёт другое значение... 
 Pyhesty: а нормальной среды разработки и отладки нет? только в браузере?
 Pyhesty: без брекпоинтов и просмотра памяти? 
 zuko3d: есть приятнаямелочь: когда пишешь код, то слева есть вкладка Last Battles. Её открываешь и видишь список. Так вот, если ты на левой позиции, то выиграл, если на правой - то проиграл. Так можно быстро находить игры, в которых ты проиграл
 Pyhesty: круто спасибо...
 zuko3d: не, нормальной среды разработки нет. Я копирую код через ctrl-c + ctrl+v и локально дебажу.
 Pyhesty: а входные параметры то же сам подаёшь?
 zuko3d: типа того. пишу код, который упаковывает входные параметры и в начале хода принтит их
 zuko3d: а локально я подменяю входные параметры тем, что было в начале "проблемного" хода
 Pyhesty: принтит в дебаг?
 zuko3d: да
 zuko3d: на чём пишешь?
 Pyhesty: а там не ограниченное окно? а то лабиринт и куча данных как бы много для этого окошка? или влезает? или архивируешь?
 Pyhesty: да на плюсах... наверное... 
 zuko3d: ну я в base64 упаковываю, но это для удобства. А так- там ограничение есть, но оно большое, я в его очень редко упираюсь
 zuko3d: если С++, то надо писать в cerr
 Pyhesty: ооо =) спасибо лайфхак)
 Pyhesty: а можно сыграть с ботом любого человека из ранкинга?
 zuko3d: вроде только из своей лиги
 zuko3d: но я не уверен. Обычно играю против босса или против топ1-3
 Pyhesty: а как сыграть против бота своей лиги? первого в списке?
 zuko3d: у тебя снизу есть выбор, кто с кем играет
 zuko3d: по умолчанию там слева ты, справа босс, видишь?
 Pyhesty: ну там не особо бос, там какой-то BLINKY - я думал это типовой бот от разработчиков
 Pyhesty: он довольно тупой...
 Pyhesty: но это если в моей лиге...
 Pyhesty: я понял, смог добавить) и теперь нормально ловлю таймаут)))
 Pyhesty: когда второй игрок... чума... в чем прикол
 zuko3d: Да, это нормально. В деревянных лигах всегда тупые боты, чтобы совсем новички тоже могли кого-то победить =) Так вот, под боссом есть надпись DELETE - её жмёшь, и освобождается место. Жмёшь ещё раз - и выбираешь против кого играть
 Pyhesty: супер! спасибо! 
 zuko3d: На мой вкус адекватные боты начинаются в золоте. Пройти в легенду - это уже надо попотеть. Ну, по крайней мере моих скиллов не хватает, чтобы сходу в легенду проходить =)
 Pyhesty: можно ещё вопрос, как ты архивируешь все данные в base64, если их нужно читать, то есть я понимаю, что могу считать все данные входные в цикле, но тогда я не смогу их распарсить в переменные и массивы, или ты сразу включаешь парсер потом из массива, который подготовил к выгрузке?
 zuko3d: А, и ещё. Почти всегда при повышении лиги меняются правила игры (усложняются) вплоть до бронзовой.
 Pyhesty: о блин... усложняются... приколько...
 zuko3d: Ща, надо отойти, минут через 10 отвечу
 Pyhesty: окок, я пока таймаут половлю... без дебага... какой же анахранизм... но я люблю бсдм...
 zuko3d: В общем, я когда пишу код, то у меня есть #define LOCAL на локальном компе. И вот под этим дефайном я считываю в режиме "распарсить base64", а не обычный вход.
 Pyhesty: ага, ок, а как ты захватываешь например 30 ход, на котором возникли проблемы, то есть в коде который выполняется на сервере и выдает в дебаг или в дебаг выдаются все 30 ходов архивированные? 
 zuko3d: каждый ход логгирую, т.е. в дебаге все 30 ходов, да.
 Pyhesty: я понимаю как считать все данные из cin, а как их считать в массив для последующей архивации и в переменные раскидать?... \
 Pyhesty: сорри, офигенно интересно просто 
 zuko3d: а, ну в плюсах нет хорошей рефлексии, так что для каждой задачи вручную пишешь свой формат хранения и парсинга =)
 Pyhesty: ааа... жестко...
 Pyhesty: а опять байтик завернуть в поток нельзя, что бы потом его опять считать?
 zuko3d: нет. Можно заморочиться с тем, чтобы читать в stringstream, а потом его либо дампить, либо из него читать как из cin.
 zuko3d: точнее не "либо", а "дампить и потом читать".
 Pyhesty: ясно =) спасибо! поговорил с тобой сэкономил кучу часов на ломание головы, как тут играть )))
 zuko3d: тут народ отзывчивый. если вопрос нормально формулируешь - ответ получишь хороший.
 Pyhesty: всё, добрался, наконец, до верха своей деревянно лиги ))) чума жесть игра ))) хаха))) блин прикольно) 
 vrabosh: зачем математики придумали слова произведение, слогаемое и прочии термины.. когда можно просто назвать переменая и результат... чего они так замарачиваются?
 vrabosh: а мне это все запоминать блин)
 Pyhesty: что такое "Send to IDE?"?
 Pyhesty: It will erase your current play configuration.
 gtj: отправить в иде, это очистит твою текущую игровую конфигурацию
 Pyhesty: ,а что такое IDE? 
 Pyhesty: и что именно отправится?
 gtj: среда разработки втекущем контексте браузерная скорее всего
 gtj: сделай бекап и затесть я не нажимал на нее
 Pyhesty: окок, завтра уже спать хочется, блокнот куда-то задевал
 gtj: наверно какието валидаторы инпуты или еще что я хз
 vrabosh: я считаю, что в школе должны висеть шпаргалки везде на стене.. челоеку надо логически научиться думать, а не запоминать за 1 урок все эти термины и свойства.
 vrabosh: потомучто когда ошибаешься несколкьо раз, потом все желание отбивает учиться.. а материал же легкий.. просто надо зубрить, что не есть хорошо.
 vrabosh: а за год хошь не хошь когда шпоргалки весят то их выучишь.
 zuko3d: Врабош, зачем вообще нужны школы? Почему государство их содержит?
 vrabosh: числитель(делимое) / знаменатель(делитель = частность - еслиб такое весело. яб уже половину понимал, что препод говорит)
 vrabosh: школы нужны, иначебы неучились вообще.. но принцип их диктаторский это жесть
 zuko3d: школы нужны государству не для вколачивания знаний, а для воспитания, обучения правильному поведению в обществе, правильным межличностным отношениям. Шпаргалки в этом не помогут.
 vrabosh: вот я в какойто момент прозивал что такое числитель итд.. считай что вся учеба на смарку.. а им тип важно чтоб я за 1 урок это запомнил.. этож бред
 vrabosh: им важно чтобы я задание выполнил, а не знания получил
 zuko3d: это ты про учителей. а я про всю систему в целом
 gtj: zuko3d смори)
 vrabosh: вот какая разница решил я задачу из ума, или взял учебник открыл и с учебником решил.. как будто в жизни я без учебника буду решать..
 gtj: <a rel="nofollow" class="external free" href="https://github.com/richkirl/graphkirk5/blob/master/graphkirk5/graphkirk5.cpp">https://github.com/richkirl/graphkirk5/blob/master/graphkirk5/graphkirk5.cpp</a>
 vrabosh: так я тоже про всю систему.. в системе нельзя подглядывать.. им важно чтобы люди зубрили
 gtj: vrabosh все что в школе дают полезно потом поймешь это
 vrabosh: а не поинмали как это работает
 vrabosh: gtj я знаю что полезно..
 vrabosh: просто как они это дают.. 
 gtj: ну есть школы с уклонами к сожалению
 vrabosh: я сейчас смотрю уроки 4-5 класса, они настолько простые.. я уже в эом возрасте программил на бейские и мне эти задачи былибы вообще легкие.. а я был по математ троищником.. потмоучто я в какойто момент термины не выучил
 gtj: ты еще в Вузе с преподом не разговаривал который в голове решает интегралы
 gtj: двойные
 gtj: и все чотко формулирует в его возрасте
 gtj: 2 часа точных определний и расчетов
 gtj: и ошибок!
 gtj: 300 человек молча слушают как правило потомучто мало кто успевает за такими мыслями
 vrabosh: когда 100 раз на бумаге чтото решишь, можно потом и в голове решать
 gtj: он придумывая задания уже ответы знал
 gtj: двойные интегралы vrabosh
 vrabosh: я не знаю что такое интеграл
 vrabosh: я только узнал что такое числитель \ знаменатель)
 gtj: ну грубо говоря цикл но так нельзя говорить
 vrabosh: ну зато за час прошел 4 класс)
 vrabosh: щаз за пару часов 5класс освою)
 gtj: а зачем
 vrabosh: я помню в 3 классе в уме считал столбиком.. потомучто понял и запомнил..
 vrabosh: хочу математику знать, а то inoryy говорит, что для ИИ ее надо знать)
 gtj: 3 класса?
 vrabosh: что 3 класса?
 vrabosh: я по порядку учу.. 
 vrabosh: первые 6 классов терминологию дают которую я не знаю.
 gtj: производные лучше поучи
 zuko3d: для ИИ бесполезно учить термины. Надо понимать суть, которая стоит за словами.
 gtj: в жизне пригодится
 gtj: да надо интерпретировать
 gtj: и линковать
 vrabosh: zuko3d а чтобы суть понять. надо понимать что написано
 zuko3d: а школа, имхо, даёт социальные навыки, а не технические.
 gtj: тебе абстракцию надо качнуть, понять теорию игр, производные, мат методы (ну мое личное мнение)
 gtj: а начать лучше с производных
 vrabosh: так може я это понимаю, просто незнаю это)
 gtj: интерпретировать что это такое и что она делает и получается
 gtj: это абстракция как раз
 gtj: не знаю можешь курс открыть любой технической специальности
 vrabosh: zuko3d мнеж не кто не будет тем языком пояснять которым я хочу)
 gtj: впринципе там все дают что надо
 vrabosh: сейчас вот таких шпаргалок наделаю себе и буду радоваться жизнью)
 vrabosh: print('Упращения выражений: ', <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/1864dfe0-2cec-4183-8870-8881b784d9cb">http://chat.codingame.com/pastebin/1864dfe0-2cec-4183-8870-8881b784d9cb</a>
 vrabosh: 25**.5, 16**.25 #(5, 2) - а так можно решать квадратные и кубические степени в обратном порядке.
 vrabosh: либо так вот m**1/(1&lt;&lt;n)
 vrabosh: m**(1/(2&lt;&lt;(n-1)))
 vrabosh: блин чего я так опечатываюсь m**(1/(1&lt;&lt;(n-1)))
 vrabosh: sqrt = lambda m,n: m**(1/(1&lt;&lt;(n-1))) # вот функция
 vrabosh: math.sqrt кнечно в 3 раза быстрее работает
 vrabosh: gtj, я скоро как ты тут начну флудить, можно же?)
 vrabosh: math.sqrt(m), m**.5 # при таком варианте разница в 10% по скорости.
 gtj: тема однострочника не раскрыта
 vrabosh: всмысле? там все понятно же
 vrabosh: в с++ такиеже вроде операторы
 vrabosh: хотя может вместо ** там ^
 gtj: <a rel="nofollow" class="external free" href="http://govnokod.ru/26787">http://govnokod.ru/26787</a>
