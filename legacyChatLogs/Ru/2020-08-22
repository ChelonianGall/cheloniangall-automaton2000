 gsomix: Uljahn, хорошая задача, с ходу не получилось решить.
 735487: у этой задачи есть четкое математическое решение. кажется там по спирали надо двигаться
 gtj: е равно мц квадрат
 gtj: задачка клевая заставляет шуршать мозг)
 gtj: есть 2 точки)
 gtj: по геометрии евклида через 2 точки можно протянуть только  линию)
 gtj: ну и есть касательные
 gtj: <a rel="nofollow" class="external free" href="https://youtu.be/pl0po4RXoGo">https://youtu.be/pl0po4RXoGo</a>
 tutubalin: а ноль зачем в памяти хранишь?
 BorisZ: я роадмап все пытаюсь доделать на главной
 BorisZ: сейчас попробую может третий тоже пройдется
 Uljahn: ну, контрибьюшны пилить я не буду, переживу незакрытые квесты
 tutubalin: это вряд ли. там есть тест, где вход в пещеру с одной стороны, а корабль с другой
 Uljahn: я и говорю - 50%
 Uljahn: вторую половину можно на костылях захардкодить
 Uljahn: типа определить, в какую сторону пещера повёрнута, и если не в нашу сторону, то по верху облететь
 BorisZ: угу, второй тест валится
 Uljahn: кстати, нашёл контрибьюшн, тоже на непрерывном поле, но без физики - тригонометрия и векторы, затянуло<a rel="nofollow" class="external free" href="https://www.codingame.com/contribute/view/533506801f34ff279f03a7774bb2e4ad3ac0">https://www.codingame.com/contribute/view/533506801f34ff279f03a7774bb2e4ad3ac0</a>
 Uljahn: мышка плавает в фонтане, Automaton2000
 Automaton2000: про то, что я хочу
 wlesavo: BorisZ тож только ветка оптима с марслендером осталась
 gybson_samara: по марслендеру есть видео где с ГА решение
 BorisZ: wlesavo у меня не только, еще и с алгоритмами, надо два very hard пазла решить, плюс еще сто-то непонятно пока
 BorisZ: gybson_samara я и делал через га, только очень давно, и оно не взлетало, вчера нашел ошибку
 wlesavo: BorisZ там еще квест на 100 ачивок, я думаю ты автоматом получишь
 BorisZ: совсем по простому - одна хромосома, без пула и только мутации без скрещиваний всяких
 wlesavo: одна хромосома без пула и скрещиваний это уже sa :slight_smile:
 BorisZ: вроде нет, должна быть там температура и остывание еще
 wlesavo: ну даже не sa  а просто жадный алгоритм
 wlesavo: если ты лучшего оставляешь
 BorisZ: постепенно сужаться вариативность должна короче
 wlesavo: ну от этого до са буквально пять строчек кода 
 YurkovAS: еще дает профит мутировать: 1 + random(N) хромосом
 wlesavo: странно, у меня тоже такое, но так и не заработало, там где-то по 40к роллаутов было, думаешь косяк в симе?
 wlesavo: мож поищу тогда вечером ошибку
 wlesavo: bulls and cows самый изи veryhard пазл, я вообще не понимаю что он в этой категории делает
 wlesavo: и резистенс еще простой, там строчек 50
 BorisZ: я уже skylines начал думать, мне он показался легким но завяз чего-то )
 gybson_samara: Uljahn лайкнул мышку =) прикольный пазл
 735487: у меня из вери хард <a rel="nofollow" class="external free" href="https://www.codingame.com/training/expert/staircases">https://www.codingame.com/training/expert/staircases</a> и <a rel="nofollow" class="external free" href="https://www.codingame.com/training/expert/shadows-of-the-knight-episode-2">https://www.codingame.com/training/expert/shadows-of-the-knight-episode-2</a>
 gybson_samara: я эпизод2 почти добил простым двойным бинарным поиском
 gybson_samara: в смысле по очереди сначала X, потом Y
 gybson_samara: def warmer(self)
 gybson_samara: питон так вызовет метод класса?
 BorisZ: да, только метод со скобочками
 gybson_samara: спс
 gybson_samara: но self.last это ссылка на метод
 gybson_samara: точно надо скобки?
 gybson_samara: хотя да, так-то и аргументы юывают =)
 BorisZ: если хочешь вызвать метод, то надо 
 BorisZ: если без скобочек то это просто ссылка на функцию
 BorisZ: я заапрувал контрибуцию а квест не выполнился 
 BorisZ: или надо ждать пока не будет принята она?
 Uljahn: эйлер в дискорде писал: "just wait for a 3rd user to vote on it. i suppose then you'll get the achievement"
 Uljahn: т.е. скорее всего надо ждать, но это не точно
 BorisZ: Uljahn спасибо, наверное так и есть, там я вторым был
 735487: никак не додумаюсь как анео пазл сделать. 80% только прохожу
 gybson_samara: там я на форуме писал константу
 gybson_samara: помогает с округлением
 735487: я не уверен что у меня с округлением проблемы
 gybson_samara: ну там такой пазл что, что скорее всего с ним
 gybson_samara: v = lc*0.277777777777777
 gybson_samara: решение очень простое
 gybson_samara: 27 строк и то с размахом
 735487: ну  у меня тоже решение простое. но не очень правильное может быть ))
 gybson_samara: там сложность с переводом из одних единиц в другие, все языки дают ошибка в N знаке
 gybson_samara: константа делает решение тривиальным
 gybson_samara: подмывает похвастать решением, но не стану =)
 735487: я попробовал влоб. перебираю скорость от большего к меньшему и пытаюсь определить на какой свет проехал
 gybson_samara: так и надо
 gybson_samara: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/c7b17d6d-df73-46e4-adfd-2e48bb8f5c47">http://chat.codingame.com/pastebin/c7b17d6d-df73-46e4-adfd-2e48bb8f5c47</a>
 gybson_samara: говорю же, вся фишка задачи в проблеме вычислений с плавающей точкой
 735487: без константы решилось. я просто чуток неправильно проверял светофоры. вместо того чтобы считать время пересечения я расстояние в цикле инкрементил )))
 tutubalin: wlesavo у меня Resistance 10 строчек )
 tutubalin: если быть точнее, то 18 строчек, из которых 4 пустые, и ещё 4 - таблица кодов Морзе.сам алгоритм ровно 10 строчек
 Uljahn: вроде бы, разные ошибки округления получаются при переводе, если сначала умножать, а потом делить, по сравнению с делить, а потом умножать :thinking:
 735487: там подойдет такое решение? берем минимальную валидную длину. и от остатка считаем количество в рекурсии. запоминаем для каких строк уже посчитано количество.  в голове вроде должно сработать ))))
 735487: а блин там еще и словарь слов&#160;:)
 735487: о а если все слова перевести в морзе и сравнить? пройдет по времени?
 gybson_samara: Uljahn ошибки может и разные, а суть одна. Делишь 1 на 3 и смотришь с какого знака ошибка пошла. Ну или другое какое деление, где в периоде
 tutubalin: amurushkin да-да. мемоизации достаточно. через DP ещё быстрее и даже вроде бы короче
 735487: я только DP не умею кроме мемоизации ))
 tutubalin: мемоизация  - это сверху вниз. начинаешь с общей задачи, запоминаешь результаты тех подзадач, которые попались в процессе
 735487: ну да это я знаю
 tutubalin: табулизация (я называю DP, но на самом деле это частный случай DP) - снизу вверх. когда сперва решаешь подзадачи, и на основе них решаешь задачи уровня выше. при это можно отбрасывать те результаты, которые уже не важны
 Dmitry_Mandzyuk: всем привет
 Dmitry_Mandzyuk: подскажите, как примерно реализуется алгоритм кольцевого списка
 Dmitry_Mandzyuk: и можно ли создать кольцевой массив
 gybson_samara: Dmitry_Mandzyuk в питоне массивы кольцевые, точнее списки
 tutubalin: Dmitry_Mandzyuk кольцевой массив - это по идее массив, где индекс берётся по модулю
 gybson_samara: tutubalin нет, в питоне -1 это последний элемент
 tutubalin: например, массив на 100 элементов. тогда 101й элемент - это 1й элемент
 gybson_samara: tutubalin ну так да
 Dmitry_Mandzyuk: ладно, тогда задам вопрос немного иначе, осциллограф возвращает массив 4 массива по 4096 элементов
 Dmitry_Mandzyuk: я вот думаю как бы так реализовать его непрерывную работу
 Dmitry_Mandzyuk: то есть он постоянно читает и возвращает это куда-то
 tutubalin: есть кольцевой буфер. по сути синоним кольцевой очереди
 gybson_samara: кого его?
 Dmitry_Mandzyuk: работу осциллографа
 Dmitry_Mandzyuk: так вот возвращает получается в кольцевой буфер
 gybson_samara: Dmitry_Mandzyuk размер буфера тесно связан со скоростью ввода и вывода информации
 Dmitry_Mandzyuk: ага, так и подозревал, но был не уверен
 Dmitry_Mandzyuk: то есть по сути надо подбирать замер этого буфера так, чтобы успевать читать да?
 gybson_samara: его размер, грубо говоря, скорость вывода деленя на скорость ввода
 gybson_samara: или наоборот =)
 tutubalin: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/91807ef7-15fb-4428-90e1-d8f4c8048ba3">http://chat.codingame.com/pastebin/91807ef7-15fb-4428-90e1-d8f4c8048ba3</a>
 tutubalin: упс. 5 строчек получилось. чат свернул в ссылку
 Dmitry_Mandzyuk: ага понял, спасибо
 gybson_samara: если тебе поступает 2 байта на вход, а ты обрабатываешь один, то нужен буфер на 2 байта все-равно
 gybson_samara: потому, что буфер должен вместить весь входящий поток
 Dmitry_Mandzyuk: у меня еще вопрос,  я пользуюсь векторами, то есть забиваю считанные данные в них, а если создать структуру, в которой содержится 4 вектора, по вектору на канал, а потом создать массив из этих структур, это ведь будет своеобразный список из блоков замеров?
 Dmitry_Mandzyuk: и в еще один вдогонку))) я копирую данные в вектора в цикле, существуют более быстрые методы?
 gybson_samara: смотря на чем пишешь
 Dmitry_Mandzyuk: на с++
 gybson_samara: memcpy
 gybson_samara: можно указать сразу источник и структуру, размер будет sizeof(struct)
 Dmitry_Mandzyuk: ага, то есть она просто копирует область памяти да?
 gybson_samara: да
 gybson_samara: это будет ппц какой плохой код в теории, но хороший в практике
 Dmitry_Mandzyuk: ))) да я уже прочитал, что ее не рекомендуют использовать
 gybson_samara: правила для дурков
 Dmitry_Mandzyuk: но если размер буфера всегда одинаков, значит ошибок быть не должно?
 gybson_samara: нет, ошибки всегда еть
 gybson_samara: с этим надо смириться
 input.txt: Dmitry_Mandzyuk лучше для начала циклом. а то частая ошибка написать что-то типа sizeof(vector), и потом часами дебажить...
 Dmitry_Mandzyuk: эх ошибки ошибки
 input.txt: серьезно, memcpy одна из самых опасных функций. крайне легко налажать в размерах источника/назначения а то и порядке аргументов
 input.txt: а циклы и так оптимизирутся компилятром
 gtj: более быстро это деревья
 gtj: со структурой думать придется самого дерева тут как тебе удобно будет
 input.txt: не бытрее
 gtj: самое простое мапы и пары в мапах
 gtj: окай
 gtj: тогда можно листом обойтись или массивом
 gtj: в то время когда ты будешь искать в одномерном массиве у него уже все будет по свойствам отфильтровано и записано в том порядке каком ему надо
 Dmitry_Mandzyuk: ох  сколько же всего я не знаю
 gtj: я бы сделал map[chanel]&lt;int&lt;vector&lt;int&gt;,int&gt;&gt;
 gtj: чтобы можно было раскладывать по науке удобнее потом поиском
 Dmitry_Mandzyuk: типа двумерный вектор?
 gtj: массив мап где н это канал
 gtj: ключ чтото там придумать
 gtj: потом в паре ключ либо гармоника либо еще что
 gtj: и второй уже ответ в виде вектора
 Dmitry_Mandzyuk: а, кстати вот еще вопрос, я это все в длл файл пишу, так вот, длл может запускать несколько потоков?
 gtj: а какие у тебя ошибки то?
 gtj: ты буфер обновляешь?
 Dmitry_Mandzyuk: ошибка в том что я данные теряю
 gtj: буфер обнулять надо не мемцпаем
 Dmitry_Mandzyuk: в то время пока рисую осц простаивает
 Dmitry_Mandzyuk: у меня буфер это vector
 Dmitry_Mandzyuk: я делаю clear перед чтением 
 gtj: ну да твои точки синусоиды в векторе это я понял
 gtj: тему ты клевую затронул
 gtj: в каком виде хранить гармоники и как с ними взаимодействовать удобно
 gtj: тебе приджется класс писать
 gtj: чтобы было боле менее удобно работать с твоей информацией
 gtj: а не важно какой буфер
 gtj: буфер это массив
 Dmitry_Mandzyuk: просто работу с осцом я делаю в виде длл библиотеки, а потом прикручиваю длл к графическому движку. И вот думаю если в длл реализовать поток чтения в виде цикла, а чтобы читало в буфер
 gtj: после того когда ты вывел его обнулить надо
 Dmitry_Mandzyuk: это я понимаю
 Dmitry_Mandzyuk: вопрос в том, длл норм с потоками работает? я просто так не делал никогда
 gtj: стой а ты на какой частоте данные кидаешь в поток
 gtj: не читаешь а осц с какой частотой генерит 
 gtj: вот например сейчас в твоем случае
 Dmitry_Mandzyuk: осц читает с частотой 250МГц
 gtj: я еще думаю может библиотеки есть какие давай я тебе кину библиотеку где есть кольцевой буфер?
 Dmitry_Mandzyuk: да я бы сам хотел реализовать
 gtj: и ты посмотришь его реализацию
 Dmitry_Mandzyuk: а ну или кидай
 Dmitry_Mandzyuk: мне Тутубалин примерный алгоритм скинул уже
 Dmitry_Mandzyuk: я пока думаю как его реализовать
 gtj: <a rel="nofollow" class="external free" href="https://github.com/kfrlib/kfr/tree/master/include/kfr">https://github.com/kfrlib/kfr/tree/master/include/kfr</a>
 gtj: ну да но его еще очищать надо
 gtj: а или не надо
 Dmitry_Mandzyuk: а если не очищать а просто перезаписывать по кругу?
 tutubalin: это и есть кольцевой буфер )
 tutubalin: когда не очищаешь, а перезаписываешь
 gtj: да я понял я просто к файлу прикидывал
 gtj: а движок игры разве дает такие возможности таким скоростям 250 мгц
 gtj: это поток же
 gtj: ну как в змейке получается
 gtj: проверка границ
 gtj: и так ходишь постоянно не бьешься о стенки
 gtj: причем источник не комп а внешнее устройство через поток через юсб 
 Dmitry_Mandzyuk: ага, значит по поводу кольцевого буфера я почти все понял)))
 Dmitry_Mandzyuk: так вот я думал, если кольцевой буфер достаточно большой, пусть осц себе читает, а я буду потихоньку отрисовывать
 Dmitry_Mandzyuk: мне ж не надо 250МГц через usb давить
 Dmitry_Mandzyuk: мне по сути надо дать команду читай и начать рисовать потихоньку
 gtj: будет глобальная задержка
 gtj: а ну мб
 gtj: так и что сейчас получается у тебя читает но рывками
 gtj: я боюсь придется писать низкоуровневые фичи типо конвеера или буфера который будет как интерфейс а оттуда уже читать потоком винды
 Dmitry_Mandzyuk: да, сейчас читает кусочками из-за задержки во время рисования
 gtj: так да тебе тогда надо глобальный кулдаун сделать
 gtj: 1 шаг читаешь
 gtj: и со второго шага по задержке в 1 шаг будет возможность читать непрерывно из буфера
 gtj: тогда задержка будет 1 шаг
 gtj: такт или в мс если брать
 gtj: 5 10 100
 gtj: тоесть
 gtj:  1 2 3 4 5 6 7 8 9 10 -&gt; бесконечность с обнулением
 gtj: тоесть забил буфер и пошел читать не с начала а середины например для того чтобы с середины читать из рассинхронизировать надо и задержку циклом сделать типо ну и таймер завести
 gtj: тикает например по 1 секунде
 gtj: или таймер или тикать
 gtj: 15 секунд подождал перед рисованием и погнал рисовать но это не точно возможно это колхоз
 gtj: ой или цикл или таймер ну и там все придется делать в состояниях чтобы было общее состояние чтобы таймер отрабатывал
 gtj: типо в евентах ждем и рисуем
 gtj: прога работает пишет в буфер а в евенте сидит кукует рисовальщик по твоей задержке
 gtj: <a rel="nofollow" class="external free" href="https://github.com/richkirl/snake/blob/master/glsnake.cpp">https://github.com/richkirl/snake/blob/master/glsnake.cpp</a>
 gtj: типо такой сущности получается но то я так подумал там на самом деле хз как сделать можно
 gtj: тут тикает и в евенте кратности типо
 gtj: кути вот дает сразу автомат искаробки другие фреймворки блин кусками библиотеки суют то тоже конечно ломает на старте восприятие(
 tutubalin: не надо флудить, пожалуйста
 gtj: сори
 Dmitry_Mandzyuk: спасибо за информацию
 gtj: вобщем тебе надо патерн автомат
 gtj: твой обьект
 gtj: твой млёк
 gtj: будет как живой организм или как алгоритм конечный автомат с состояниями более точными а захват процесса как бы произойдет
 gtj: по времени и состояниям
 gtj: тоесть буквально будешь управлять через время программой
 gtj: вот кути дает это простым наследованием
 gtj: QGLWidget"а
 gtj: сразу малька дает
 gtj: <a rel="nofollow" class="external free" href="https://imgur.com/a/FtqiKoH">https://imgur.com/a/FtqiKoH</a>
 gtj: <a rel="nofollow" class="external free" href="https://imgur.com/a/o1ZChqx">https://imgur.com/a/o1ZChqx</a>
 gtj: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/49716e6f-671f-4d0f-9266-ea2ec5ecf59c">http://chat.codingame.com/pastebin/49716e6f-671f-4d0f-9266-ea2ec5ecf59c</a>
 Dmitry_Mandzyuk: я в принципе уже реализовал, но передача данных идет в цикле, поэтому надо что-то типа memcpy, а еще, вдруг скорость потока осциллографа больше чем скорость считывания на отрисовку, он тогда его получается догонит по кругу 
 gtj: у тебя 1 к 1?
 gtj: или у тебя задержка?
 gtj: если у тебя вектор там есть метод очистки
 Dmitry_Mandzyuk: я не знаю как проверить 1к 1 ил нет
 gtj: заведи хроно
 gtj: хроно это секунда частота
 gtj: нам надо 3/4 периода подождать и начать вывод на екран
 gtj: это калибровка
 gtj: исходных данных
 gtj: период надо отмерить в осцилографе
 gtj: рисовать предположительно должна начать смотря какая у тебя функция на екране косинус или синус
 gtj: либо с максимума начнет либо с минимума
 gtj: когда откалибруемся можно со временем поиграть
 gtj: и подвести какбудто ползунком время как можно ближе вывода к началу буфера
 gtj: если ты понял о чем я
 gtj: тоесть если ты зафиксировал хотябы примерно где осцилограф
 gtj: где буфер
 gtj: и где рисование
 gtj: можно будет более точно настроится и прочее 
 gtj: временем задержки
 gtj: 3.14 милисекунды подождать надо
 gtj: если от 10 пляшем хотя там на осциле у тебя более точно видно
 gtj: если не охота парится и работает тогда забей и просто очищай буфер когда происходит условие типо заполнился
 gtj: хотя тут 3 визитера мб есть смысл так откалибровывать
 gtj: а ну да логично даже если в бесконечность потом уйдет все равно есть смысл откалиброваться это же кольцо оно будет очищаться перезаписываться значит перед началом сесси нужна калибровка вроде так хотя я вот прям точно не знаю как професионалы делают
 gtj: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/309ab894-8aa8-4663-a8b0-b756e98decf4">http://chat.codingame.com/pastebin/309ab894-8aa8-4663-a8b0-b756e98decf4</a>
