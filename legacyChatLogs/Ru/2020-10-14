 gsomix: Доброе утро.
 gsomix: OCaml вгоняет в уныние.
 gsomix: Придется расчехлить C#, пока F# не починили.&#160;:)
 gsomix: Никаких сроков не сообщают, а поиграть в мульти хочется.
 MadKnight: я тут игрался с функциональным прогом 
 MadKnight: стилем
 MadKnight: кто тут когда-либо юзал ФП&#160;?
 gsomix: Я думаю, что в том или ином объеме -- все юзали. ФП фичи-то во все языки проникают.&#160;:)
 MadKnight: да, но а более глобально?
 gsomix: Ну, я сейчас работаю над проектом на F#. Считается?
 gsomix: Но там без фанатизма, если нужно ООП, то и его используем.&#160;:)
 gsomix: Я, правда, не настоящий сварщик. В том смысле, что профессионально программированием не занимаюсь.
 Uljahn: так, это моя реплика!
 gsomix: Uljahn, пардоньте.&#160;:)
 amurushkin: котоботов 100% занимался
 gsomix: О, прикольно, он на Scala пишет.
 amurushkin: ухты в одном тесте у меня аж 131к собралось в клетке
 wlesavo: слушайте, а как вьювер отключить в 2048? что это за опция - и как ее включить
 wlesavo: а все, понял, туплю чето
 amurushkin: я просто в начале строки - вывожу и все
 wlesavo: ну да, я сразу не понял чет
 gsomix: F# починили.&#160;:)
 gsomix: Я снова с вами.
 Uljahn: :metal:
 Crazo: хотел ворваться в F# из C#, но все руки не доходят. Как оно вообще? Приятней?
 MadKnight: он на функциональном проге
 MadKnight: придётся кучу workaround'ов пилтиь
 magaiti: а кому оно нужно вообще, этот F#?
 MadKnight: так это ФП версия шарпов
 magaiti: и?
 Crazo: ну это если переносить проект, а я так, в целом. Я слышал, что f# это .нет питон
 MadKnight: ну и значит для любителей ФП и шарпов
 MadKnight: ненене Crazo это ФП
 magaiti: на вики пишут что это FP .NET
 MadKnight: Crazo ФП значит что переменные будут immutable
 MadKnight: magaiti ну да, шарпы на .NET
 magaiti: это не главное
 magaiti: главное что ф-ции это данные первого сорта
 MadKnight: всмысле
 magaiti: хотя щас веде так по идее
 MadKnight: что значит первого сорта
 Crazo: это когда у твоих функций голубой код
 magaiti: <a rel="nofollow" class="external free" href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0</a>
 MadKnight: Crazo короче f# на любителей
 MadKnight: Crazo к какому стилю ты склоняешься?
 magaiti: первого класса, сорянчик
 MadKnight: ты любишь кодить красиво и надёжно?
 MadKnight: или ты просто пилишь код функций и не запариваешься?
 Crazo: я шарпист, оопшник. В питоне обычно процедурно пишу. Полагал, что f# такой же гибкий, как питон, что ты можешь там, по сути, как угодно писать
 MadKnight: неее
 magaiti: Второй закон Вейнберга: если бы строители строили здания так же, как программисты пишут программы, первый залетевший дятел разрушил бы цивилизацию
 Uljahn: Automaton2000: монады монадировали, монадировали, да не вымонадировали
 MadKnight: всё дело в инструментариях на самом деле
 Automaton2000: ну да, я это и имел в виду
 Crazo: мне кажется я пропустил что-то между "неее" и монадами
 MadKnight: Crazo покажи какой-нить свой код
 Crazo: могу код для подов скинуть
 Crazo: гоночки то бишь
 MadKnight: он большй?
 MadKnight: скинь чёнить прям интересное
 MadKnight: чтобы код был хороший прям
 Crazo: у меня особо нет ниче, я ток пришел сюда, до жестких вещей еще не дошел. Сейчас пишу проход по графу для ghost in cell
 MadKnight: ну вот, GitC код покажи
 MadKnight: GitC = ghost in cell
 Crazo: я вчера ночью только попробовал управление=) <a rel="nofollow" class="external free" href="https://pastebin.com/w0qqbFJR">https://pastebin.com/w0qqbFJR</a>
 MadKnight: ну тебе явно не идёт ФП
 Crazo: ну да, фп я никогда не любил:D
 MadKnight: ну так F# это же ФП
 Crazo: ну я понял. Я просто думал, что он и для процедурки подходит
 MadKnight: какой процедурки
 Crazo: процедурного программирования, ака как обычно в питоне
 MadKnight: а, всмысле с mutable переменными
 MadKnight: вот только они там immutable
 Uljahn: тогда это не переменные уже&#160;:)
 magaiti: величины
 magaiti: постоянные
 magaiti: как я понимаю, сейчас во всех серьезных языках величины делают иммутабл по умолчанию
 magaiti: в с++ нельзя из-за совместимости со старым кодом, но рекомендуют все что можно объявлять как const
 magaiti: просто полувековой опыт программирования
 MadKnight: в с++ это же для типов в функциях, magaiti
 MadKnight: и для методов классов
 magaiti: для всего
 MadKnight: например?
 MadKnight: и зачем переменные рекомендуют максимально const делать?
 magaiti: проще читать код, проще отлавливать ошибки, больше возможностей для оптимизации компилятором
 MadKnight: в с++ бы нормальный синтаксис и базовые библиотеки завезли
 MadKnight: тогда это было бы проще
 magaiti: синтаксис не завезут, тк критична совместимость со старым кодом
 magaiti: чем тебе STL не нравися?
 magaiti: ну вот за последние годы завезли auto, лямбды
 magaiti: много чего из буста перетищили в STL
 MadKnight: всмысле чем не нравится
 MadKnight: как ты на нём массивы в 1 строчку сгенеришь?
 MadKnight: из других массивов
 magaiti: например?
 magaiti: и как базовые библиотеки должны это решать, по твоему?
 MadKnight: как вот в шарпах есть .Where и .Select
 magaiti: я не шарю в шарпах, скеажи чего надо добиться
 magaiti: в STL есть куча алгоритмов
 magaiti: .select это по идее copy_if
 magaiti: или transform, я хз
 MadKnight: надо чтобы это можно было запихнуть в одно выражение
 MadKnight: в одно выражение после const someVar = ...
 magaiti: xnj - 'nj&amp;
 MadKnight: magaiti
 MadKnight: go
 magaiti: ну, над этим работают
 magaiti: <a rel="nofollow" class="external free" href="https://habr.com/ru/post/440388/">https://habr.com/ru/post/440388/</a>
 magaiti: библиотеки есть, только не входят в стандарт пока
 magaiti: Select вообще что делает? странное название
 magaiti: преобразует значения?
 MadKnight: это transform()
 MadKnight: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/3b3f44ed-077a-4b3f-b550-d422a3249ec2">http://chat.codingame.com/pastebin/3b3f44ed-077a-4b3f-b550-d422a3249ec2</a>
 MadKnight: std::vector&lt;A&gt; v={...};auto it = ranges::find_if(
 MadKnight: жуть просто синтаксис
 magaiti: конечно, многоточия в твоем приере намного красивее
 MadKnight: const someVar = someArr.Where(a =&gt; a.id == 4);
 MadKnight: const someVar = 
 magaiti: ну если ты поменяешь синтаксис в плюсах, то будут уже не плюсы
 magaiti: пропадет совместимость с си
 magaiti: а модных клонов с++ навалом
 magaiti: ну и как ты должен догадываться, у тебя япример из языка с динамической типизацией
 MadKnight: &gt; в с++ бы нормальный синтаксис и базовые библиотеки завезли&gt; тогда это было бы прощео том и речь
 magaiti: библиотеки есть, просто синтаксис такой
 MadKnight: ааааа
 MadKnight: я имел ввиду - нормальные базовые библиотеки
 magaiti: базовые это какие?
 MadKnight: чтобы можно было нормально делать
 magaiti: это синтаксис
 MadKnight: не мешает добавить конструкций
 magaiti: <a rel="nofollow" class="external free" href="https://www.boost.org/doc/libs/1_72_0/libs/range/doc/html/range/reference/algorithms/introduction.html">https://www.boost.org/doc/libs/1_72_0/libs/range/doc/html/range/reference/algorithms/introduction.html</a>
 MadKnight: в любом случае - я имел ввиду что - с++ не особо приспособлен под этот стиль, не хватает вот этих штук
 magaiti: подключай и наслаждайся
 MadKnight: так тут опять
 MadKnight: booost::copy_if(arr
 MadKnight: похоже на ассемблер
 MadKnight: mov eax, 0copy_if eax, stuff
 magaiti: тебе название не нравится?
 magaiti: using Where = boost::copy_if;
 MadKnight: мы же о твоей штуке говорим
 MadKnight: const someVar = copy_if(
 MadKnight: вот так нам надо
 MadKnight: а название неважно
 MadKnight: а вместо этого у нас получаетсяnot_const ourVec = vector&lt;&gt;(size);copy_if(vec1, ourVec);transform(ourVec, ourVec);
 MadKnight: &gt;  проще читать код, проще отлавливать ошибки, больше возможностей для оптимизации компилятором 
 gsomix: Crazo, на F# можно писать как на питоне.
 MadKnight: gsomix а переменные там mutable&#160;?
 magaiti: чего не достичь?
 MadKnight: константной переменной
 magaiti: мы можем достичь большего чем без нее
 MadKnight: не можем сделать ourVec констом
 magaiti: можем, если у нас будет ф-ция возвращающай вектор
 gsomix: MadKnight, и так и сяк. Это функционально-императивный язык, как и OCaml.
 MadKnight: в шарпах возвращают итератор
 gsomix: magaiti, мне нужен FE.
 gsomix: *F#
 magaiti: я не занимаюсь продажами F#
 gsomix: magaiti, ты спрашивал, кому нужен F#.
 gsomix: Я отвечаю.
 MadKnight: который проходит по элементам массива когда ты итерируешься по ним, а не возвращает уже готовый массив
 magaiti: ну брейнфак тоже кому-то нужен
 magaiti: <a rel="nofollow" class="external free" href="https://github.com/Ky6uk/PETOOH">https://github.com/Ky6uk/PETOOH</a>
 gsomix: magaiti, и к чему тогда эти вопросы?&#160;:)
 MadKnight: т.е.foreach(var v in arr.Where(x=&gt;x&lt;4).Select(x=&gt;x*x)){
 gsomix: MadKnight, ты хочешь Rust.
 magaiti: вопрос в том какие на нем есть серьезные проекты, например
 MadKnight: он превратит в foreach(var v in arr)
 MadKnight: и в итоге .Where() в шарпах будет даже быстрее плюсовых
 magaiti: на плюсах тоже можно свой итератор замутить
 MadKnight: так почему бы его не возвращать?
 MadKnight: чё за фигня с бегин ендом
 magaiti: если си шарп быстрее  плюсовых, значит ты неправильно написал на плюсах
 MadKnight: чё за ночной кошмар
 gsomix: magaiti, я не занимаюсь продажами F#.&#160;;)
 MadKnight: ночной кошмар шарписта - передавать бегин енд
 MadKnight: magaiti я имел ввиду быстрее плюсовых генераций промежуточных векторов
 magaiti: промежуточные вектра можно пропустиьь, если это будет нужно
 MadKnight: хорошо, как в плюсах сделать перебор по отфильтрованному вектору?
 magaiti: <a rel="nofollow" class="external free" href="https://stackoverflow.com/questions/23579832/why-is-there-no-transform-if-in-the-c-standard-library">https://stackoverflow.com/questions/23579832/why-is-there-no-transform-if-in-the-c-standard-library</a>
 magaiti: там пример использования BoostRanges
 MadKnight: 
 magaiti: ну как, придется цикл писать
 MadKnight: да ты всё проглядел
 MadKnight: это всё тот же&#160;::copy
 MadKnight: т.е. генерится промежуточный вектор
 magaiti: там копи идет на аутпут
 MadKnight: и как его перенаправить на перебор?
 magaiti: это и есть перебор
 magaiti:  v | filtered(arg1&#160;% 2) | transformed(arg1 * arg1 / 7.0),
 MadKnight: на твой цикл перебора
 MadKnight: на твой код для одного элемента
 MadKnight: на тело цикла короче
 MadKnight: скинь вариант с кастомным телом цикла
 magaiti: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/67ebd79f-21f3-46fa-909f-b3fc82fb3473">http://chat.codingame.com/pastebin/67ebd79f-21f3-46fa-909f-b3fc82fb3473</a>
 MadKnight: в любом случае выглядит это как-то ваще ненаглядно и не интуитивно понятно
 MadKnight: Invalid paste id, perhaps it expired?
 MadKnight: WASTED
 gsomix: Пора обратно в дискорд перебираться.&#160;:)
 MadKnight: почему
 gsomix: А то тут филиал чатика по плюсам скоро будет.
 magaiti: <a rel="nofollow" class="external free" href="http://chat.codingame.com/pastebin/e04ddcd9-eaf3-489c-a2e8-b9bd567ce5f4">http://chat.codingame.com/pastebin/e04ddcd9-eaf3-489c-a2e8-b9bd567ce5f4</a>
 magaiti: [vv
 MadKnight: так присоединяйся
 MadKnight: 4 строчки magaiti
 MadKnight: максимум
 magaiti: for( auto const&amp; elem&#160;: coll ){
 gsomix: MadKnight, не, если я буду смотреть в сторону нативных языков, то только Rust или D.
 MadKnight: gsomix расскажи нам чё знаешь по плюсам
 gsomix: MadKnight, когда-то писал на С++03.
 MadKnight: так а где здесь инлайновый фильтр, magaiti&#160;?
 magaiti: чего-чего?
 MadKnight: .Where()
 magaiti: if (pred(elem))
 MadKnight: да это ты вручную
 MadKnight: с этим всё ясно
 magaiti: ye lf
 magaiti: ну да
 MadKnight: а с .Where как&#160;?
 MadKnight: или как вернуть итератор по фильтрованному массиву?
 MadKnight: return arr.Where()
 magaiti: чтоб вернуть итератор по отфильтрованному массиву, его надо написать
 MadKnight: for (elem: filteredList())
 MadKnight: а в бусте есть итераторы?
 magaiti: с++ не заточен под lazy evaluation
 magaiti: есть
 MadKnight: в шарпах кстати эти итераторы генерятся на ходу
 MadKnight: для .Where
 MadKnight: для кода самого .Where
 magaiti: <a rel="nofollow" class="external free" href="https://www.boost.org/doc/libs/1_66_0/libs/iterator/doc/html/iterator/specialized/filter.html">https://www.boost.org/doc/libs/1_66_0/libs/iterator/doc/html/iterator/specialized/filter.html</a>
 magaiti: <a rel="nofollow" class="external free" href="https://www.boost.org/doc/libs/1_66_0/libs/iterator/doc/html/iterator/specialized/transform.html">https://www.boost.org/doc/libs/1_66_0/libs/iterator/doc/html/iterator/specialized/transform.html</a>
 magaiti: шарп это динамический язык
 MadKnight: begin() end() опять
 MadKnight: ужс
 MadKnight: и вообще
 MadKnight: это не то
 MadKnight: это просто перенаправление значений в callback
 magaiti: чем это не то?
 magaiti: here по другому работает?
 MadKnight: так это redirect 
 MadKnight: чтобы писало не в out_vector а в callback
 magaiti: where как-то по другому работает?
 MadKnight: так lazy же
 magaiti: ну и тут lazy
 MadKnight: неее
 MadKnight: тут не lazy
 MadKnight: тут redirect
 magaiti: как нет
 MadKnight: instant
 magaiti: разница?
 MadKnight: instant redirect
 MadKnight: исполняется сразу
 magaiti: и?
 MadKnight: фильтруется сразу
 magaiti: что исполняется?
 MadKnight: фильтр
 MadKnight: перебор
 magaiti: сразу это когда?
 MadKnight: когда вызываешь copy
 MadKnight: или filter
 magaiti: а когда на where вызываешь copy? там не сразу?
 MadKnight: так в шарпах итератор возвращается
 magaiti: ну и тут итератор
 MadKnight: var iter = arr.Where(x=&gt;x&lt;3)
 MadKnight: вот итератор
 MadKnight: теперь мы можем
 magaiti: auto iter = boost::make_transform_iterator(x + N, boost::bind1st(std::plus&lt;int&gt;(), 4)),
 MadKnight: foreach(var el in iter) - и вот тут он начнёт проходить по arr и фильтровать его
 magaiti: н тут муть какая-то с bindom
 MadKnight: &gt; typedef 
 MadKnight: ммм
 magaiti: и у нас начнет когда начнем iter разыменовывать
 MadKnight: у этого итератора нету информации о размере
 magaiti: нету
 magaiti: нужен 2-й итератор на конец
 MadKnight: фором по нему не пройтись
 magaiti: по 2-м итераторам можно
 MadKnight: а как их совместись чтобы фором пройтись?
 magaiti: можно слепить объект который будет работать как твой итератор
 magaiti: определить у него методы begin и end
 magaiti: и пройтись
 MadKnight: ну короче целый фреймворк пилить, заменяя весь std
 magaiti: ну прям заменяя
 magaiti: ну прям весь
 MadKnight: это буст же
 MadKnight: был
 MadKnight: всю часть с массивами всмысле
 magaiti: это просто не нужно в задачах, где нужен с++
 MadKnight: так тебе же нужно const
 magaiti: зачем пилить клон C# на плюсах, когда есть C#
 MadKnight: затем что ты сам сказал - нужны консты
 MadKnight: в плюсах
 magaiti: да, нужны
 MadKnight: а для конст нужно инлайновое объявление
 magaiti: это просто делается по другому
 MadKnight: как
 magaiti: зависит от того зачем нам константный вектор
 gsomix: for v in arr.iter().filter(|&amp;&amp;x| x&lt;4).map(|x| x*x) { ... } :relieved:
 MadKnight: вектор всех свободных клеток на карте например
 MadKnight: всех '.' и не '#'
 amurushkin: тю это в каждом контесте без проблем делал и не парился
 magaiti: const auto v = get_free_Cells(grid);
 MadKnight: amurushkin но ты не делал это const
 amurushkin: похоже мэд вкурил с# и он теперь весь мир хочет ему научить
 MadKnight: amurushkin ты пропустил начало диалога видимо
 magaiti: он просто доебался
 amurushkin: го срач что лучше Java или C#
 MadKnight: мы говорим о том как последовать совету magaiti и сделать массив const
 amurushkin: не пропустил. меня задрало уже просто его читать
 magaiti: эскобар
 MadKnight: в с++
 MadKnight: да я с# как пример привёл лол
 MadKnight: могу любой другой как пример взять
 amurushkin: а в руби клеши короче&#160;:)
 magaiti: го ассемблер
 MadKnight: на асме слишком просто
 MadKnight: не интересно
 magaiti: <a rel="nofollow" class="external free" href="https://iphlib.ru/library/collection/newphilenc/document/HASHb46c3b239b40034c0488b4">https://iphlib.ru/library/collection/newphilenc/document/HASHb46c3b239b40034c0488b4</a>
 BorisZ: клеши – ложные наполнители сознания:astonished:
 Lobs: а каким образом тут кодировать
 BorisZ: Lobs выбираешь задачку, читаешь условия, выбираешь язык и решаешь
 BorisZ: что не понятно - спрашиваешь в чат, обычно отвечают, но может не сразу
 amurushkin: <a rel="nofollow" class="external free" href="https://imgur.com/a/O0WmKfz">https://imgur.com/a/O0WmKfz</a> и это еще не предел
 BorisZ: ходы то закончились 601 - выходит предел?
 BorisZ: или там бесконечная строка может быть с аутпутом?
 amurushkin: 601 предел
 amurushkin: но за 1 тик до 10к ходов
 BorisZ: мне кажется что должен быть теоретический предел - максимальное число
 BorisZ: чтобы собрать следующее надо разместить на 16 клетках все предыдущие степени двойки
 magaiti: первый софткап - 43к ходов, там сложно накопить на 131к rktnre
 magaiti: клетку
 BorisZ: типа 2**17 - это все, потому что чтобы собрать 2**18 надо все степени разместить в своих клетках
 magaiti: типа того
 BorisZ: или я что-то упускаю
 magaiti: 131к можно собрать, 262 скорее всего нет
 magaiti: но почти всегда проигрывает с 64к
 magaiti: 4 4 8 16 / 32 64 128 256 / 512 1k 2k 4k / 8k 16k 32k 64k
 wlesavo: BorisZ и то еще нужно чтобы 4ка появилась в последней клетке чтобы собрать 2^17
 magaiti: так собирается 128к
 BorisZ: да, тоже нарисовал такую цепочку)
 magaiti: все что набирает 50м+ доходят до 64к во всех тестах, или почти всех
 wlesavo: блин, я как-то не подумал что 131к это последнее число
 wlesavo: 64к вроде изи
 magaiti: нужен прорыв - способ собрать 128к
 wlesavo: magaiti так не во всех тестах это впринципе возможно, если на конкретном ходу появляется двойка всегда, то как ни старайся не сможешь собрать 131
 magaiti: разве нельзя кол-во ходов подмансить?
 wlesavo: нет, оно фиксированое по логике
 wlesavo: потому что у тебя вся борда заставлена
 wlesavo: вот если бы сид был завязан на совершаемое действие
 wlesavo: это было бы интересно
 magaiti: хм, 2 и 4 у нас выпадают детерминированно, сумма на доске от сливаний не меняется
 magaiti: похоже да
 wlesavo: так что похоже у дбдра может быть близко к пределу уже
 magaiti: можно затестить
 magaiti: валить тест если двойка выпала
 wlesavo: ну да если дошел до конца и дваойку собрал
 BorisZ: за несколько ходов до этого, когда горизонталь еще не полностью забита 0 4 8 16 - можно либо влево либо вправо двигать
 amurushkin: magaiti: нужен прорыв - способ собрать 128к, ну вот на скрине у меня глянь я смог на одном тесте ))
 wlesavo: amurushkin он имеет ввиду на всех тестах 
 magaiti: 0 4 8 16 только влево моно
 BorisZ: за ход или за два то этого можно и туда и сюда ведь?
 BorisZ: кагда 8 делается
 magaiti: хз, ты же их по любому оба проверишь
 wlesavo: BorisZ за один ход появляется детерминированное число, так что сумма чисел на доске к конкретному ходу детерминирована
 magaiti: да-да
 magaiti: можно сразу рассчитать
 magaiti: на 1-м ходу
 wlesavo: кстати да, можно заранее знать сможешь ты или нет набрать
 magaiti: будет у тебя 256к или 256к - 2
 wlesavo: только не очень полезное знание
 magaiti: можно быстро засабмитить и посмотреть
 magaiti: валить тест или ходить инвалидом, в зависимости
 magaiti: и рассчитать теор максимум
 wlesavo: а, в этом смысле да
 BorisZ: вы просто тут писали что глубина у всех 6-7 ходов, я и подумал что может под конец стоит глубину увеличивать, все равно вариантов мало остается
 wlesavo: не, это у меня только 6-7
 magaiti: у меня 3
 wlesavo: она собирает 64к но на 131 неспособна
 BorisZ: это если можно не одним вариантом к концовке придти а несколькими
 magaiti: пытаться набрутфорсит
 wlesavo: magaiti у тебя глубина 3 чего?
 BorisZ: если нельзя то все это в пустоту рассуждения мои конечно
 magaiti: одного шага
 wlesavo: так у тебя не бимсерч чтоли?
 magaiti: бим
 wlesavo: ну глубина луча то какая 
 magaiti: из всех позиций через 3 хода берем N 
 magaiti: глубина 3
 magaiti: на 7 долго перебирать же
 wlesavo: да не, ты же потом идешь дальше, следующее поколение, и суммарная макс глубина должна быть какаято
 magaiti: какую успею
 magaiti: от шрины зависит
 magaiti: потом беру лучшего по змейке и отезжаю назад поколений на 10
 magaiti: и вывожу
 wlesavo: ну вот, суммарная глубина под 30 получается
 magaiti: аа
 magaiti: ты бо этом
 magaiti: кол-во ходов которые я отрезаю
 magaiti: хз, это все голимая эвристика
 magaiti: знать бы как гарантированно 131к собрать
 wlesavo: ну грубо говоря на сколько шагов вперед смотришь, это я имею ввиду под глубиной
 magaiti: типа того, но я вперед тоже лучом смотрю, а не брутом
 magaiti: получается
 YurkovAS: видимо за счет этого хорошо играет
 wlesavo: ну не брутом но таки смотришь
 magaiti: 55 стабильно беру, хочется больше&#160;:)
 YurkovAS: есть поддержка уникальности?
 magaiti: есть
 magaiti: додумался в какой-то момент
 YurkovAS: а дисконт?
 magaiti: в змейке есть, иначе фитнес будет у всех одинаковый
 wlesavo: magaiti а сколько у тебя змеек считается кстати?
 magaiti: дисконт 0.9
 YurkovAS: на каждой глубине еще дисконт
 YurkovAS: 0.99
 magaiti: 2 змейки зеркально
 YurkovAS: дает профит и суммируешь их все
 magaiti: хз я каждый раз на 0.9 умножаю
 magaiti: 16 раз
 YurkovAS: всмысле скор от змейки накапливаешь на всех глубинах
 magaiti: то есть 16 клеток змейкой, i-я клетка с дисконтом 0.9^i
 YurkovAS: и змейка сама с дисконтом
 magaiti: у евс не так?
 wlesavo: зачем на всех глубинах копить
 magaiti: да что значит сама змейка?
 magaiti: каждый этаж еще?
 YurkovAS: на каждом ходу считаем скор (змейка) * 0.9^depth
 magaiti: wlesavo, а как надо?
 YurkovAS: и в ноду записываем - накапливаем
 MadKnight: чё за змейка?
 magaiti: оценочная для 2048
 magaiti: я хз о чем ты
 magaiti: у меня оценочная на позицию
 magaiti: а не на ход
 wlesavo: у меня тож
 magaiti: вообще была мысль хранить разной глубины, например 6 и 7
 YurkovAS: я про то, что оценку наследовать от родительских.
 magaiti: а почему она должна наследоваться?
 magaiti: хмм
 magaiti: возможно в этом чтото есть
 YurkovAS: а почему бы и нет
 YurkovAS: так делают.
 magaiti: потеряешь точность
 YurkovAS: еще есть такое?2 фазы:1. находим Н1 лучших для типа хода (4 ваиранта). 2. из предыдущих берем Н2 лучших
 magaiti: какого хода?
 YurkovAS: т.е. отдельно топ-н влево, вправо и т.д.а потом уже из них набираем общий топ-н (со своей шириной)
 magaiti: а смысл набирать общий
 YurkovAS: а, ну чтобы потом по нему проще было пройтись
 magaiti: точнее если мы набираем общий, то смысл отдельно перед этим набирать
 magaiti: какой ход ты имеешь в виду? первый, посделний, будущий?
 magaiti: если фитнес зависит от истории, то у одинаковых позиций может быть разный фитнес, их тогда только по доске придется различать
 magaiti: как тогда дубликаты искать
 YurkovAS: да, похоже нет смысла разделять.скопипастил из др игры.гиперсоника
 magaiti: я строго не проверял, но по идее сумма по змейке уникальна для каждой позиции
 magaiti: с точностью до поворотов и отражений
 YurkovAS: у тебя уникальность - по скору от змейки?
 magaiti: то есть она же может служить ключом и величиной для упорядочивания
 magaiti: в итоге да, по скору
 magaiti: сначала проверял скор, потом доску. потом проверк доски выкинул
 YurkovAS: эх, у меня по обычному скору и состоянию доски
 magaiti: я обычный скор выкинул
 magaiti: считыываю в переменную и не использую
 magaiti: хотя он показывает, как хорошо слились клетки
 YurkovAS: с хешкодом от змейки хуже на 10млн.может надо теперь параметры менять
 magaiti: а этот твой хеш только от текущей позиции зависит?
 YurkovAS: только от оценки змейкой
 magaiti: но ты говорил что твоя оценка зависит от оценки предыдущей позиции
 YurkovAS: а, я про отслеживание уникальности стейта
 magaiti: для уникальности отдельно считаешь?
 magaiti: тогда хз, параметры
 magaiti: может у меня и не лучшая оценка
 YurkovAS: да, для уникальности было: обычный скор + состояние доски.
 magaiti: ну вот, а стало что?
 magaiti: змейка по текущей позиции, без добавки от предыдущих?
 YurkovAS: поменял на змейку.в общем, я тебя недопонял, видимо
 magaiti: ну, у меня фитнесс это змейка только от текущей позиции, и ее же использую как уникальный хеш
 magaiti: и по нему же можно искать лучших
 magaiti: но возможно это не оптимальнвый вариант для поиска лучших решений
 magaiti: интересно, написано The validators differ from puzzle testcases
 magaiti: но они же называются как сид
 magaiti: то есть имена врут или валидаторы те же
 wlesavo: это общая надпись ,конкретно в 2048 совпадают
 magaiti: опаньки
 magaiti: надо как-то забрутить
 magaiti: собрать базу эндшпилей
 wlesavo: нашел гениальную эвристику, но почему то она работает только с 4мя действиями а не с тремя
 magaiti: как на 131к выйт
 magaiti: DRUL?
 wlesavo: да не, язаметил что в брутфорсе часто угол забивается маленьким числом, и свреху закрывается большим, и решил за это наказывать
 wlesavo: yj d ,bvcthxt levf. ytn nfrjq ghj,ktvs
 wlesavo: но в бимсерче думаю нет такой проблемы
 magaiti: мм, надо вот как - если есть позиция где 8 клеток занято правильно, давать бонус
 wlesavo: можно просто считать сколько позиций занято правильно и за это бонус
 wlesavo: но не уверен что поможет как то
 magaiti: не, надо 4 или 8
 magaiti: они там сидят подолгу
 magaiti: остальные то тасуются влево-вправо
 magaiti: ну хотя хз
 magaiti: проблема в том что последовательность 2 и 4 появляющихся случайная, но ддля конкретного сида можно сделать базу хардкодов
 magaiti: если тесты совпадают то все кроме случайного сида можно захардкодить
 magaiti: как ходить с такого-то хода до сборки 131к
 magaiti: для всех вариантов доски или наиболее частых
 YurkovAS: сид читается из поля - "testIn"
 magaiti: читается, но я предлагаю базу сделать, а она для каждого сида своя
 magaiti: первый тест - рандомный сид
 magaiti: на него не сделать
 YurkovAS: а он и не юзается в проде"isValidator": "false"
 magaiti: про какие поля ты говоишь?
 YurkovAS: <a rel="nofollow" class="external free" href="https://github.com/eulerscheZahl/2048/blob/master/config/test1.json">https://github.com/eulerscheZahl/2048/blob/master/config/test1.json</a>
 magaiti: ну там можно сид узнать, ну так я его и из теста узнаю
 magaiti: распечатав на 1-м ходу
 magaiti: хмм, сколько ходов 512 собирать надо?
 magaiti: в среднем 3 за ход
 magaiti: 256 ходов максимум
 magaiti: где-то 600 ходов можно в 100к символов запихать, если не париться с архивацией
 magaiti: немного
 magaiti: скажем 15 из 30 валидаторов могут собрать 131к, по 60 позиций на каждый... надо наиболее частые найти из выигрышных. 
 magaiti: планов громадьё
 amurushkin: поправлю. в 100к символов можно 100к запихать
 magaiti: нужно 10 к на код допустим
 magaiti: по 100-150 символов на шестнадцатиричную запись фитнеса и последовательности ходов для него
 magaiti: получается 600-900 фитнесов
 magaiti: можно не 16-ричную запись использоватЬ, а ббольше
 magaiti: все равно, жто надо будет в оффлайне провоить исследования
 magaiti: стоит ли игра свеч
 magaiti: ну кстати если 8 клеток занято уже, и на конкретном ходу сумма чисел в остальных 8 известна, то наверное не так много позиций есть разных
 magaiti: для конкретного исда
 magaiti: сида*
 magaiti: опять же надо выбрать ход правильный, на каком искать. чтоб был наибольший шанс найти просчитанную позицию
 magaiti: у меня щас времени на это все нет
 magaiti: а так идею дарю&#160;:)
 amurushkin: а какой теоеретический максимальный счет?
 magaiti: хз, 131к в углу и по змейке, это позиция. а счет надо считать
 magaiti: я 3.3 ляма видел
 magaiti: по идее 3.4, то есть в 2 раза больше чем 1.7
 magaiti: с копейками
 magaiti: а полный в лидерборде зависит от того какие валидаторы в принципе могут 131 собрать
 magaiti: 2.8 чаще всего вижу когда выше 1.7, видимо там тоже трудно преодолеть
 amurushkin: 3.3 я смог выжать на одном сиде
 amurushkin: но стабильности при сабмитах вообще никакой
 magaiti: а, там такая же фигня собирается как только вместо 65к там 131 в углу, то ест ьтоже должно повезти с 4-й , второй раз
 magaiti: вот я и кумекаю как стабильность повысить
 wlesavo: amurushkin на котором если не секрет?
 amurushkin: wlesavo: на 8
 magaiti: у меня тут еще мысль, выдавать ходы понемногу, а самому дойти до определенного хода и там дфсить, до 600 хода по 50мс
 wlesavo: тоже была мысль придерживать ходы
 magaiti: но счет 3.3 это 76к ходов
 magaiti: нужен некоторый запас
 amurushkin: чет не понял в чем идея
 amurushkin: я всегда некоторый лимит выдаю в оутпут
 magaiti: ты досчитываешь скажем до 42к хода
 amurushkin: а ищет пока время есть
 magaiti: а дальше ищешь пока есть время, все время, то есть 600 на 50мс
 magaiti: а выдаешь по 1 ходу, потом находишь как собрать 131 и начинаешь по 10к выдавать
 amurushkin: нифига не понял что ты имеешь ввиду
 magaiti: ну смотри
 magaiti: надо найти как собрать 131
 magaiti: это может занят ьбольше 50мс
 magaiti: допустим за 50 мс мы ответ не нашли, и даже не знаем, из нашей позиции вообще есть выигрышный вариант
 magaiti: а ход надо делать
 magaiti: вот мы даем один ход из буфера ищем дальше 
 magaiti: не бим серчем, а дфсом или как-то еще
 magaiti: то есть с возвратом
 magaiti: чтоб было куда возвращаться, тянем время
 amurushkin: а понял теперь
 amurushkin: пока типа не найдет
 magaiti: ну если за 595 ходов не нашли, то выдаем чт оесть
 magaiti: лучшее сохраняем на этот случай,н например
 i-antares: привет, я совсем ноль в программировании, мне пока сюда лучше не соваться? подскажите пожалуйста
 magaiti: за советом обращайся
 magaiti: это общий чат, по всем вопросам
 magaiti: мы тут трындим просто
 i-antares: ты мне?
 magaiti: да
 amurushkin: но смотря насколько ты ноль. хоть что то желательно знать конечно
 magaiti: если есть вопросы по задачкам, можешь спрашивать
 magaiti: ест ьсовсем простые
 magaiti: задачи
 magaiti: для твоего уровня
 i-antares: ну я с C# так немного знаком
 i-antares: magaiti пишу в лс
 magaiti: ты ведь прошел onboarding?
 i-antares: да
 wlesavo: блин эвристики работают вроде но прироста не дали, обидно
 magaiti: что за эвристики? как 131 собрать?
 wlesavo: не, как дольше не проигрывать с маленькой глубиной скорее
 magaiti: а
 magaiti: если 131 собрать то дольше можно не проигрывать)
 amurushkin: 131 когда собирается это сколько очков будет? 
 wlesavo: в районе 3м
 amurushkin: нет я имею ввиду в момент сбора
 magaiti: 1.7 + 262 и дальше сколько наберешь
 wlesavo: это зависит от состояния доски еще немного
 magaiti: 1.74 счет когда не собираешь
 amurushkin: понятно
 magaiti: макс.счет когда не собрал + 131 + 65 + ...
 amurushkin: почему в иде я все время набираю больше чем при сабмитах?
 magaiti: он запускает 30 сразу наверное
 magaiti: и начитается конкуренция за ядра
 magaiti: либо просто конкуренция с другими сабмитами, но хз чем иде тогда отличается
 amurushkin: лучше бы на 30 разных машинах
 YurkovAS: amurushkin первый тест Random seed не надо учитывать
 amurushkin: почему? он же есть в валидаторах
 magaiti: рандом да
 magaiti: он случайный
 YurkovAS: он не запускается на проде
 amurushkin: ну ладно пусть его не учитываем. все равно в иде больше&#160;:)
 wlesavo: за него либо ничего не дается либо не запускается, да
 amurushkin: а почему он в списках есть?
 amurushkin: более того он у меня 1 раз падал
 wlesavo: скорее всего там хардкодно за него 0 дается
 magaiti: хомм, тогда теоретический максимум есть и фиксированный
 wlesavo: у меня так было в быках коровах за валидатор длинны 1 всегда 5 очков
 magaiti: сиды все фиксированы
 wlesavo: magaiti так не факт что существует решение для теоретического максимума
 magaiti: ну как не существует
 magaiti: теоретически можно найти конечным перебором
 wlesavo: ну может быть такое теоретически что че не делай раньше проиграешь
 amurushkin: даже если не учитывать 1 тест все равно. сабмитнул только что на 52 а в иде 56 уже набрал
 magaiti: ну вот когда проиграешь - это и бдет максимум
 magaiti: может у тебя скрипт неправильный?
 magaiti: который сумму считает
 amurushkin: че там неправильного? сложить просто
 amurushkin: он у меня и по каждому тесту выдает результат. все правильно
 amurushkin: 57098572 в иде набрал
 magaiti: ну судя по тому что валидаторы падают чаще чем в иде, они и считают медленнее
 magaiti: и за 600 ходов могут до 3 миллионов не успеть 
 magaiti: например
 amurushkin: во на 54608480 сабмитнул. уже интереснее
 Uljahn: так в иде 31 тест с учётом рандомного сида, а валидаторов 30, ты правильно суммируешь?
 magaiti: 31-го теста нет 
 magaiti: в валидаторах
 magaiti: лул
 Uljahn: в details ошибка похоже, названия валидаторов неправильные, или типа того
 magaiti: правильные
 magaiti: последнего теста нет
 magaiti: либо неправильные
 magaiti: и нет рандомного
 magaiti: хз
 magaiti: можно выяснить, если ронять тест по заданному сиду
 Uljahn: ну правильно, роняю на сиде 290797, а красный валидатор 01 Random seed
 Uljahn: typical off-by-one error
 magaiti: хмм, а когда меньше 8 клеток остается, уже трудно работать
 magaiti: может сделать 2 этажа змейка, а потом лесенка
 magaiti: то есть елочка
 magaiti: у меня стал вместо 52-54 набирать 56
 magaiti: но хочется больше конечно
 magaiti: а может у дбдра и правда максимальный счет
 amurushkin: а чем лесенка по 2 полосам от змейки отличается?
 magaiti: очередностью клеток
 magaiti: сначала по вертикали
 magaiti: хмм, 14 тестов могут набрать 2.8м
 magaiti: из них 4 могут 3.3
 magaiti: то есть теоретический максимум где-то 70 лямов
 magaiti: хз насчет лесенки на самом деле
 YurkovAS: о, сабмиты норм играют
 YurkovAS: и опять забанили...они серваки чтоли ребутали недавно
 amurushkin: у меня весь вечер капча с картинками. задолбали
 Mosha: Доброго времени суток, товарищи! Есть заклинатели змей?
 Mosha: А ладно, я придумал, как проще устроить, спасибо за внимание
