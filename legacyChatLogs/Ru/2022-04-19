 tutubalin: я вот только не понял, зачем они некоторые вещи называют иначе. например, trait — это ж по сути интерфейс.
 tutubalin: правда, не совсем, конечно. может быть именно из-за небольших различий, чтобы путаницы не было.
 tutubalin: awnion не зависимо от того, кто где работает, восприятие информации идёт примерно одинаково. подача материала может быть удобной для читателя, а может быть неудобной.
 tutubalin: вот в вышеуказанной книжке по расту подача материала очень хорошая. не создаёт ненужного напряжения. информация заливается легко и непринуждённо
 tutubalin: блин, дочитал до lifetime и очарование языка сразу пропало
 tutubalin: я ожидал, что не может всё быть так шоколадно и где-то должна быть подстава. и вот она нашлась.
 Uljahn: это про жизненный цикл объектов? конструкторы, деструкторы, освобождение памяти?
 Uljahn: "A lifetime is a construct the compiler uses to ensure all borrows are valid."
 Uljahn: Automaton2000: м, ясно
 Automaton2000: дальше пространство вариантов схлопывается довольно быстро
 AntonBlockchain: людям надоело считать инвалидные объекты. это нельзя делать в реальном времени см java\c#. и по этому считаем все объекты валидными в пределах валидного потока. 
 tutubalin: ну вот они говорят: "В С++ надо самому память освобождать, в Java это делает тормозной GC, а у нас компилятор сам находит, когда память освободить в простой и безопасной манере"
 AntonBlockchain: меньше ошибок в коде. меньше дыр в коде. получается инвалидируется сразу слой объектов. - а в простом коде == никогда.
 tutubalin: в реальности надо на каждом углу прописывать ручками эти самые lifetime. не то чтобы это было сильно сложно. но я ожидал магию
 AntonBlockchain: фактически они провоцируют не освобождать память в потоке. а освождать сразу после того как поток выполнения закрылся.
 AntonBlockchain: что закрывает целый класс атак и ошибок.
 AntonBlockchain: за это платится тем что все живет пока не умрет поток. 
 AntonBlockchain: целиком
 AntonBlockchain: раньше так и писали embedded. все в линейном простанстве и все живет пока не умрет поток. потом из-за ограничения адресации! появилось выделение памяти. больше чем в 64к адресовать было нельзя
 AntonBlockchain: в 32 бит. а по идее все это выделение памяти это костыль. если бы была возможность адресовать в едином адресном пространстве то можно было это все обеспечить в виде стека (в сткае живут массивы и объекты а их валидность определяется стеком вызовов) или в виде глобальной адресации.
 Uljahn: раньше не было проблемы спекулятивного исполнения и инвалидации кэшей, а теперь приходится костыли накручивать
